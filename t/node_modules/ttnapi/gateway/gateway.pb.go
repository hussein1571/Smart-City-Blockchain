// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: github.com/TheThingsNetwork/api/gateway/gateway.proto

package gateway // import "github.com/TheThingsNetwork/api/gateway"

import proto "github.com/gogo/protobuf/proto"
import golang_proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import strconv "strconv"

import bytes "bytes"

import encoding_binary "encoding/binary"

import strings "strings"
import reflect "reflect"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type LocationMetadata_LocationSource int32

const (
	// The source of the location is not known or not set
	LocationMetadata_UNKNOWN LocationMetadata_LocationSource = 0
	// The location is determined by GPS
	LocationMetadata_GPS LocationMetadata_LocationSource = 1
	// The location is fixed by configuration
	LocationMetadata_CONFIG LocationMetadata_LocationSource = 2
	// The location is set in and updated from a registry
	LocationMetadata_REGISTRY LocationMetadata_LocationSource = 3
	// The location is estimated with IP Geolocation
	LocationMetadata_IP_GEOLOCATION LocationMetadata_LocationSource = 4
)

var LocationMetadata_LocationSource_name = map[int32]string{
	0: "UNKNOWN",
	1: "GPS",
	2: "CONFIG",
	3: "REGISTRY",
	4: "IP_GEOLOCATION",
}
var LocationMetadata_LocationSource_value = map[string]int32{
	"UNKNOWN":        0,
	"GPS":            1,
	"CONFIG":         2,
	"REGISTRY":       3,
	"IP_GEOLOCATION": 4,
}

func (LocationMetadata_LocationSource) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_gateway_cd729bb602de8f80, []int{0, 0}
}

type LocationMetadata struct {
	// Time (unix nanoseconds)
	Time int64 `protobuf:"varint,1,opt,name=time,proto3" json:"time,omitempty"`
	// the northâ€“south position (degrees; -90 to +90), where 0 is the equator, north pole is positive, south pole is negative
	Latitude float32 `protobuf:"fixed32,2,opt,name=latitude,proto3" json:"latitude,omitempty"`
	// the east-west position (degrees; -180 to +180), where 0 is the Prime Meridian (Greenwich), east is positive , west is negative
	Longitude float32 `protobuf:"fixed32,3,opt,name=longitude,proto3" json:"longitude,omitempty"`
	// the altitude (meters), where 0 is the mean sea level
	Altitude int32 `protobuf:"varint,4,opt,name=altitude,proto3" json:"altitude,omitempty"`
	// the accuracy of the location (meters)
	Accuracy             int32                           `protobuf:"varint,5,opt,name=accuracy,proto3" json:"accuracy,omitempty"`
	Source               LocationMetadata_LocationSource `protobuf:"varint,6,opt,name=source,proto3,enum=gateway.LocationMetadata_LocationSource" json:"source,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                        `json:"-"`
	XXX_sizecache        int32                           `json:"-"`
}

func (m *LocationMetadata) Reset()      { *m = LocationMetadata{} }
func (*LocationMetadata) ProtoMessage() {}
func (*LocationMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_gateway_cd729bb602de8f80, []int{0}
}
func (m *LocationMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LocationMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LocationMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *LocationMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LocationMetadata.Merge(dst, src)
}
func (m *LocationMetadata) XXX_Size() int {
	return m.Size()
}
func (m *LocationMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_LocationMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_LocationMetadata proto.InternalMessageInfo

func (m *LocationMetadata) GetTime() int64 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *LocationMetadata) GetLatitude() float32 {
	if m != nil {
		return m.Latitude
	}
	return 0
}

func (m *LocationMetadata) GetLongitude() float32 {
	if m != nil {
		return m.Longitude
	}
	return 0
}

func (m *LocationMetadata) GetAltitude() int32 {
	if m != nil {
		return m.Altitude
	}
	return 0
}

func (m *LocationMetadata) GetAccuracy() int32 {
	if m != nil {
		return m.Accuracy
	}
	return 0
}

func (m *LocationMetadata) GetSource() LocationMetadata_LocationSource {
	if m != nil {
		return m.Source
	}
	return LocationMetadata_UNKNOWN
}

type RxMetadata struct {
	GatewayID string `protobuf:"bytes,1,opt,name=gateway_id,json=gatewayId,proto3" json:"gateway_id,omitempty"`
	// Indicates whether the gateway is trusted. Components that are able to verify gateway trust MUST do so and set this value accordingly
	GatewayTrusted bool `protobuf:"varint,2,opt,name=gateway_trusted,json=gatewayTrusted,proto3" json:"gateway_trusted,omitempty"`
	// Timestamp (uptime of LoRa module) in microseconds with rollover
	Timestamp uint32 `protobuf:"varint,11,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	// Time in Unix nanoseconds
	Time int64 `protobuf:"varint,12,opt,name=time,proto3" json:"time,omitempty"`
	// Encrypted time from the Gateway FPGA
	EncryptedTime []byte                `protobuf:"bytes,13,opt,name=encrypted_time,json=encryptedTime,proto3" json:"encrypted_time,omitempty"`
	RfChain       uint32                `protobuf:"varint,21,opt,name=rf_chain,json=rfChain,proto3" json:"rf_chain,omitempty"`
	Channel       uint32                `protobuf:"varint,22,opt,name=channel,proto3" json:"channel,omitempty"`
	Antennas      []*RxMetadata_Antenna `protobuf:"bytes,30,rep,name=antennas" json:"antennas,omitempty"`
	// Frequency in Hz
	Frequency uint64 `protobuf:"varint,31,opt,name=frequency,proto3" json:"frequency,omitempty"`
	// Received signal strength in dBm
	RSSI float32 `protobuf:"fixed32,32,opt,name=rssi,proto3" json:"rssi,omitempty"`
	// Signal-to-noise-ratio in dB
	SNR                  float32           `protobuf:"fixed32,33,opt,name=snr,proto3" json:"snr,omitempty"`
	Location             *LocationMetadata `protobuf:"bytes,41,opt,name=location" json:"location,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *RxMetadata) Reset()      { *m = RxMetadata{} }
func (*RxMetadata) ProtoMessage() {}
func (*RxMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_gateway_cd729bb602de8f80, []int{1}
}
func (m *RxMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RxMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RxMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RxMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RxMetadata.Merge(dst, src)
}
func (m *RxMetadata) XXX_Size() int {
	return m.Size()
}
func (m *RxMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_RxMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_RxMetadata proto.InternalMessageInfo

func (m *RxMetadata) GetGatewayID() string {
	if m != nil {
		return m.GatewayID
	}
	return ""
}

func (m *RxMetadata) GetGatewayTrusted() bool {
	if m != nil {
		return m.GatewayTrusted
	}
	return false
}

func (m *RxMetadata) GetTimestamp() uint32 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *RxMetadata) GetTime() int64 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *RxMetadata) GetEncryptedTime() []byte {
	if m != nil {
		return m.EncryptedTime
	}
	return nil
}

func (m *RxMetadata) GetRfChain() uint32 {
	if m != nil {
		return m.RfChain
	}
	return 0
}

func (m *RxMetadata) GetChannel() uint32 {
	if m != nil {
		return m.Channel
	}
	return 0
}

func (m *RxMetadata) GetAntennas() []*RxMetadata_Antenna {
	if m != nil {
		return m.Antennas
	}
	return nil
}

func (m *RxMetadata) GetFrequency() uint64 {
	if m != nil {
		return m.Frequency
	}
	return 0
}

func (m *RxMetadata) GetRSSI() float32 {
	if m != nil {
		return m.RSSI
	}
	return 0
}

func (m *RxMetadata) GetSNR() float32 {
	if m != nil {
		return m.SNR
	}
	return 0
}

func (m *RxMetadata) GetLocation() *LocationMetadata {
	if m != nil {
		return m.Location
	}
	return nil
}

type RxMetadata_Antenna struct {
	Antenna uint32 `protobuf:"varint,1,opt,name=antenna,proto3" json:"antenna,omitempty"`
	Channel uint32 `protobuf:"varint,2,opt,name=channel,proto3" json:"channel,omitempty"`
	// Received signal power in dBm
	RSSI float32 `protobuf:"fixed32,3,opt,name=rssi,proto3" json:"rssi,omitempty"`
	// Received channel power in dBm
	ChannelRSSI float32 `protobuf:"fixed32,5,opt,name=channel_rssi,json=channelRssi,proto3" json:"channel_rssi,omitempty"`
	// Standard deviation of the RSSI
	RSSIStandardDeviation float32 `protobuf:"fixed32,6,opt,name=rssi_standard_deviation,json=rssiStandardDeviation,proto3" json:"rssi_standard_deviation,omitempty"`
	// Frequency offset (Hz)
	FrequencyOffset int64 `protobuf:"varint,7,opt,name=frequency_offset,json=frequencyOffset,proto3" json:"frequency_offset,omitempty"`
	// Signal-to-noise-ratio in dB
	SNR float32 `protobuf:"fixed32,4,opt,name=snr,proto3" json:"snr,omitempty"`
	// Encrypted fine timestamp from the Gateway FPGA
	EncryptedTime []byte `protobuf:"bytes,10,opt,name=encrypted_time,json=encryptedTime,proto3" json:"encrypted_time,omitempty"`
	// Fine timestamp from the Gateway FPGA (decrypted)
	FineTime             int64    `protobuf:"varint,11,opt,name=fine_time,json=fineTime,proto3" json:"fine_time,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RxMetadata_Antenna) Reset()      { *m = RxMetadata_Antenna{} }
func (*RxMetadata_Antenna) ProtoMessage() {}
func (*RxMetadata_Antenna) Descriptor() ([]byte, []int) {
	return fileDescriptor_gateway_cd729bb602de8f80, []int{1, 0}
}
func (m *RxMetadata_Antenna) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RxMetadata_Antenna) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RxMetadata_Antenna.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RxMetadata_Antenna) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RxMetadata_Antenna.Merge(dst, src)
}
func (m *RxMetadata_Antenna) XXX_Size() int {
	return m.Size()
}
func (m *RxMetadata_Antenna) XXX_DiscardUnknown() {
	xxx_messageInfo_RxMetadata_Antenna.DiscardUnknown(m)
}

var xxx_messageInfo_RxMetadata_Antenna proto.InternalMessageInfo

func (m *RxMetadata_Antenna) GetAntenna() uint32 {
	if m != nil {
		return m.Antenna
	}
	return 0
}

func (m *RxMetadata_Antenna) GetChannel() uint32 {
	if m != nil {
		return m.Channel
	}
	return 0
}

func (m *RxMetadata_Antenna) GetRSSI() float32 {
	if m != nil {
		return m.RSSI
	}
	return 0
}

func (m *RxMetadata_Antenna) GetChannelRSSI() float32 {
	if m != nil {
		return m.ChannelRSSI
	}
	return 0
}

func (m *RxMetadata_Antenna) GetRSSIStandardDeviation() float32 {
	if m != nil {
		return m.RSSIStandardDeviation
	}
	return 0
}

func (m *RxMetadata_Antenna) GetFrequencyOffset() int64 {
	if m != nil {
		return m.FrequencyOffset
	}
	return 0
}

func (m *RxMetadata_Antenna) GetSNR() float32 {
	if m != nil {
		return m.SNR
	}
	return 0
}

func (m *RxMetadata_Antenna) GetEncryptedTime() []byte {
	if m != nil {
		return m.EncryptedTime
	}
	return nil
}

func (m *RxMetadata_Antenna) GetFineTime() int64 {
	if m != nil {
		return m.FineTime
	}
	return 0
}

type TxConfiguration struct {
	// Timestamp (uptime of LoRa module) in microseconds with rollover
	Timestamp uint32 `protobuf:"varint,11,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	RfChain   uint32 `protobuf:"varint,21,opt,name=rf_chain,json=rfChain,proto3" json:"rf_chain,omitempty"`
	// Frequency in Hz
	Frequency uint64 `protobuf:"varint,22,opt,name=frequency,proto3" json:"frequency,omitempty"`
	// Transmit power in dBm
	Power int32 `protobuf:"varint,23,opt,name=power,proto3" json:"power,omitempty"`
	// LoRa polarization inversion (basically always true for messages from gateway to node)
	PolarizationInversion bool `protobuf:"varint,31,opt,name=polarization_inversion,json=polarizationInversion,proto3" json:"polarization_inversion,omitempty"`
	// FSK frequency deviation in Hz
	FrequencyDeviation   uint32   `protobuf:"varint,32,opt,name=frequency_deviation,json=frequencyDeviation,proto3" json:"frequency_deviation,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TxConfiguration) Reset()      { *m = TxConfiguration{} }
func (*TxConfiguration) ProtoMessage() {}
func (*TxConfiguration) Descriptor() ([]byte, []int) {
	return fileDescriptor_gateway_cd729bb602de8f80, []int{2}
}
func (m *TxConfiguration) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxConfiguration) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxConfiguration.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TxConfiguration) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxConfiguration.Merge(dst, src)
}
func (m *TxConfiguration) XXX_Size() int {
	return m.Size()
}
func (m *TxConfiguration) XXX_DiscardUnknown() {
	xxx_messageInfo_TxConfiguration.DiscardUnknown(m)
}

var xxx_messageInfo_TxConfiguration proto.InternalMessageInfo

func (m *TxConfiguration) GetTimestamp() uint32 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *TxConfiguration) GetRfChain() uint32 {
	if m != nil {
		return m.RfChain
	}
	return 0
}

func (m *TxConfiguration) GetFrequency() uint64 {
	if m != nil {
		return m.Frequency
	}
	return 0
}

func (m *TxConfiguration) GetPower() int32 {
	if m != nil {
		return m.Power
	}
	return 0
}

func (m *TxConfiguration) GetPolarizationInversion() bool {
	if m != nil {
		return m.PolarizationInversion
	}
	return false
}

func (m *TxConfiguration) GetFrequencyDeviation() uint32 {
	if m != nil {
		return m.FrequencyDeviation
	}
	return 0
}

// message Status represents a status update from a Gateway.
type Status struct {
	// Timestamp (uptime of gateway) in microseconds with rollover
	Timestamp uint32 `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	// Time in Unix nanoseconds
	Time int64 `protobuf:"varint,2,opt,name=time,proto3" json:"time,omitempty"`
	// Indicates whether the gateway is trusted. Components that are able to verify gateway trust MUST do so and set this value accordingly
	GatewayTrusted bool `protobuf:"varint,3,opt,name=gateway_trusted,json=gatewayTrusted,proto3" json:"gateway_trusted,omitempty"`
	// Boot time in Unix nanoseconds
	BootTime     int64    `protobuf:"varint,4,opt,name=boot_time,json=bootTime,proto3" json:"boot_time,omitempty"`
	IP           []string `protobuf:"bytes,11,rep,name=ip" json:"ip,omitempty"`
	Platform     string   `protobuf:"bytes,12,opt,name=platform,proto3" json:"platform,omitempty"`
	ContactEmail string   `protobuf:"bytes,13,opt,name=contact_email,json=contactEmail,proto3" json:"contact_email,omitempty"`
	Description  string   `protobuf:"bytes,14,opt,name=description,proto3" json:"description,omitempty"`
	// The gateway's frequency plan: one of EU_863_870, US_902_928, CN_779_787, EU_433, AU_915_928, CN_470_510, AS_923, AS_920_923, AS_923_925, KR_920_923
	FrequencyPlan string `protobuf:"bytes,15,opt,name=frequency_plan,json=frequencyPlan,proto3" json:"frequency_plan,omitempty"`
	// The value of Bridge is set by the Bridge
	Bridge string `protobuf:"bytes,16,opt,name=bridge,proto3" json:"bridge,omitempty"`
	// The value of Router is set by the Router
	Router string `protobuf:"bytes,17,opt,name=router,proto3" json:"router,omitempty"`
	// Version of Gateway FPGA
	FPGA uint32 `protobuf:"varint,18,opt,name=fpga,proto3" json:"fpga,omitempty"`
	// Version of Gateway DSP software
	DSP uint32 `protobuf:"varint,19,opt,name=dsp,proto3" json:"dsp,omitempty"`
	// Version of gateway driver (in X.X.X format)
	HAL      string            `protobuf:"bytes,20,opt,name=hal,proto3" json:"hal,omitempty"`
	Location *LocationMetadata `protobuf:"bytes,21,opt,name=location" json:"location,omitempty"`
	// Round-trip time to the server in milliseconds
	RTT uint32 `protobuf:"varint,31,opt,name=rtt,proto3" json:"rtt,omitempty"`
	// Total number of received uplink packets since boot
	RxIn uint32 `protobuf:"varint,41,opt,name=rx_in,json=rxIn,proto3" json:"rx_in,omitempty"`
	// Total number of successful (correct) uplink packets since boot
	RxOk uint32 `protobuf:"varint,42,opt,name=rx_ok,json=rxOk,proto3" json:"rx_ok,omitempty"`
	// Total number of received downlink packets since boot
	TxIn uint32 `protobuf:"varint,43,opt,name=tx_in,json=txIn,proto3" json:"tx_in,omitempty"`
	// Total number of successfully sent downlink packets since boot
	TxOk uint32 `protobuf:"varint,44,opt,name=tx_ok,json=txOk,proto3" json:"tx_ok,omitempty"`
	// Total number of packets received from link testing mote, with CRC OK
	LmOk uint32 `protobuf:"varint,45,opt,name=lm_ok,json=lmOk,proto3" json:"lm_ok,omitempty"`
	// Sequence number of the first packet received from the link testing mote
	LmSt uint32 `protobuf:"varint,46,opt,name=lm_st,json=lmSt,proto3" json:"lm_st,omitempty"`
	// Sequence number of the last packet received from the link testing mote
	LmNw uint32 `protobuf:"varint,47,opt,name=lm_nw,json=lmNw,proto3" json:"lm_nw,omitempty"`
	// Number of lost PPS pulses
	LPPS uint32            `protobuf:"varint,48,opt,name=l_pps,json=lPps,proto3" json:"l_pps,omitempty"`
	OS   *Status_OSMetrics `protobuf:"bytes,51,opt,name=os" json:"os,omitempty"`
	// debug or warning messages from the gateway
	Messages             []string `protobuf:"bytes,52,rep,name=messages" json:"messages,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Status) Reset()      { *m = Status{} }
func (*Status) ProtoMessage() {}
func (*Status) Descriptor() ([]byte, []int) {
	return fileDescriptor_gateway_cd729bb602de8f80, []int{3}
}
func (m *Status) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Status) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Status.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Status) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Status.Merge(dst, src)
}
func (m *Status) XXX_Size() int {
	return m.Size()
}
func (m *Status) XXX_DiscardUnknown() {
	xxx_messageInfo_Status.DiscardUnknown(m)
}

var xxx_messageInfo_Status proto.InternalMessageInfo

func (m *Status) GetTimestamp() uint32 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *Status) GetTime() int64 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *Status) GetGatewayTrusted() bool {
	if m != nil {
		return m.GatewayTrusted
	}
	return false
}

func (m *Status) GetBootTime() int64 {
	if m != nil {
		return m.BootTime
	}
	return 0
}

func (m *Status) GetIP() []string {
	if m != nil {
		return m.IP
	}
	return nil
}

func (m *Status) GetPlatform() string {
	if m != nil {
		return m.Platform
	}
	return ""
}

func (m *Status) GetContactEmail() string {
	if m != nil {
		return m.ContactEmail
	}
	return ""
}

func (m *Status) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Status) GetFrequencyPlan() string {
	if m != nil {
		return m.FrequencyPlan
	}
	return ""
}

func (m *Status) GetBridge() string {
	if m != nil {
		return m.Bridge
	}
	return ""
}

func (m *Status) GetRouter() string {
	if m != nil {
		return m.Router
	}
	return ""
}

func (m *Status) GetFPGA() uint32 {
	if m != nil {
		return m.FPGA
	}
	return 0
}

func (m *Status) GetDSP() uint32 {
	if m != nil {
		return m.DSP
	}
	return 0
}

func (m *Status) GetHAL() string {
	if m != nil {
		return m.HAL
	}
	return ""
}

func (m *Status) GetLocation() *LocationMetadata {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *Status) GetRTT() uint32 {
	if m != nil {
		return m.RTT
	}
	return 0
}

func (m *Status) GetRxIn() uint32 {
	if m != nil {
		return m.RxIn
	}
	return 0
}

func (m *Status) GetRxOk() uint32 {
	if m != nil {
		return m.RxOk
	}
	return 0
}

func (m *Status) GetTxIn() uint32 {
	if m != nil {
		return m.TxIn
	}
	return 0
}

func (m *Status) GetTxOk() uint32 {
	if m != nil {
		return m.TxOk
	}
	return 0
}

func (m *Status) GetLmOk() uint32 {
	if m != nil {
		return m.LmOk
	}
	return 0
}

func (m *Status) GetLmSt() uint32 {
	if m != nil {
		return m.LmSt
	}
	return 0
}

func (m *Status) GetLmNw() uint32 {
	if m != nil {
		return m.LmNw
	}
	return 0
}

func (m *Status) GetLPPS() uint32 {
	if m != nil {
		return m.LPPS
	}
	return 0
}

func (m *Status) GetOS() *Status_OSMetrics {
	if m != nil {
		return m.OS
	}
	return nil
}

func (m *Status) GetMessages() []string {
	if m != nil {
		return m.Messages
	}
	return nil
}

// Additional metrics from the operating system
type Status_OSMetrics struct {
	Load_1               float32  `protobuf:"fixed32,1,opt,name=load_1,json=load1,proto3" json:"load_1,omitempty"`
	Load_5               float32  `protobuf:"fixed32,2,opt,name=load_5,json=load5,proto3" json:"load_5,omitempty"`
	Load_15              float32  `protobuf:"fixed32,3,opt,name=load_15,json=load15,proto3" json:"load_15,omitempty"`
	CPUPercentage        float32  `protobuf:"fixed32,11,opt,name=cpu_percentage,json=cpuPercentage,proto3" json:"cpu_percentage,omitempty"`
	MemoryPercentage     float32  `protobuf:"fixed32,21,opt,name=memory_percentage,json=memoryPercentage,proto3" json:"memory_percentage,omitempty"`
	Temperature          float32  `protobuf:"fixed32,31,opt,name=temperature,proto3" json:"temperature,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Status_OSMetrics) Reset()      { *m = Status_OSMetrics{} }
func (*Status_OSMetrics) ProtoMessage() {}
func (*Status_OSMetrics) Descriptor() ([]byte, []int) {
	return fileDescriptor_gateway_cd729bb602de8f80, []int{3, 0}
}
func (m *Status_OSMetrics) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Status_OSMetrics) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Status_OSMetrics.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Status_OSMetrics) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Status_OSMetrics.Merge(dst, src)
}
func (m *Status_OSMetrics) XXX_Size() int {
	return m.Size()
}
func (m *Status_OSMetrics) XXX_DiscardUnknown() {
	xxx_messageInfo_Status_OSMetrics.DiscardUnknown(m)
}

var xxx_messageInfo_Status_OSMetrics proto.InternalMessageInfo

func (m *Status_OSMetrics) GetLoad_1() float32 {
	if m != nil {
		return m.Load_1
	}
	return 0
}

func (m *Status_OSMetrics) GetLoad_5() float32 {
	if m != nil {
		return m.Load_5
	}
	return 0
}

func (m *Status_OSMetrics) GetLoad_15() float32 {
	if m != nil {
		return m.Load_15
	}
	return 0
}

func (m *Status_OSMetrics) GetCPUPercentage() float32 {
	if m != nil {
		return m.CPUPercentage
	}
	return 0
}

func (m *Status_OSMetrics) GetMemoryPercentage() float32 {
	if m != nil {
		return m.MemoryPercentage
	}
	return 0
}

func (m *Status_OSMetrics) GetTemperature() float32 {
	if m != nil {
		return m.Temperature
	}
	return 0
}

func init() {
	proto.RegisterType((*LocationMetadata)(nil), "gateway.LocationMetadata")
	golang_proto.RegisterType((*LocationMetadata)(nil), "gateway.LocationMetadata")
	proto.RegisterType((*RxMetadata)(nil), "gateway.RxMetadata")
	golang_proto.RegisterType((*RxMetadata)(nil), "gateway.RxMetadata")
	proto.RegisterType((*RxMetadata_Antenna)(nil), "gateway.RxMetadata.Antenna")
	golang_proto.RegisterType((*RxMetadata_Antenna)(nil), "gateway.RxMetadata.Antenna")
	proto.RegisterType((*TxConfiguration)(nil), "gateway.TxConfiguration")
	golang_proto.RegisterType((*TxConfiguration)(nil), "gateway.TxConfiguration")
	proto.RegisterType((*Status)(nil), "gateway.Status")
	golang_proto.RegisterType((*Status)(nil), "gateway.Status")
	proto.RegisterType((*Status_OSMetrics)(nil), "gateway.Status.OSMetrics")
	golang_proto.RegisterType((*Status_OSMetrics)(nil), "gateway.Status.OSMetrics")
	proto.RegisterEnum("gateway.LocationMetadata_LocationSource", LocationMetadata_LocationSource_name, LocationMetadata_LocationSource_value)
	golang_proto.RegisterEnum("gateway.LocationMetadata_LocationSource", LocationMetadata_LocationSource_name, LocationMetadata_LocationSource_value)
}
func (x LocationMetadata_LocationSource) String() string {
	s, ok := LocationMetadata_LocationSource_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *LocationMetadata) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LocationMetadata)
	if !ok {
		that2, ok := that.(LocationMetadata)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Time != that1.Time {
		return false
	}
	if this.Latitude != that1.Latitude {
		return false
	}
	if this.Longitude != that1.Longitude {
		return false
	}
	if this.Altitude != that1.Altitude {
		return false
	}
	if this.Accuracy != that1.Accuracy {
		return false
	}
	if this.Source != that1.Source {
		return false
	}
	return true
}
func (this *RxMetadata) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RxMetadata)
	if !ok {
		that2, ok := that.(RxMetadata)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.GatewayID != that1.GatewayID {
		return false
	}
	if this.GatewayTrusted != that1.GatewayTrusted {
		return false
	}
	if this.Timestamp != that1.Timestamp {
		return false
	}
	if this.Time != that1.Time {
		return false
	}
	if !bytes.Equal(this.EncryptedTime, that1.EncryptedTime) {
		return false
	}
	if this.RfChain != that1.RfChain {
		return false
	}
	if this.Channel != that1.Channel {
		return false
	}
	if len(this.Antennas) != len(that1.Antennas) {
		return false
	}
	for i := range this.Antennas {
		if !this.Antennas[i].Equal(that1.Antennas[i]) {
			return false
		}
	}
	if this.Frequency != that1.Frequency {
		return false
	}
	if this.RSSI != that1.RSSI {
		return false
	}
	if this.SNR != that1.SNR {
		return false
	}
	if !this.Location.Equal(that1.Location) {
		return false
	}
	return true
}
func (this *RxMetadata_Antenna) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RxMetadata_Antenna)
	if !ok {
		that2, ok := that.(RxMetadata_Antenna)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Antenna != that1.Antenna {
		return false
	}
	if this.Channel != that1.Channel {
		return false
	}
	if this.RSSI != that1.RSSI {
		return false
	}
	if this.ChannelRSSI != that1.ChannelRSSI {
		return false
	}
	if this.RSSIStandardDeviation != that1.RSSIStandardDeviation {
		return false
	}
	if this.FrequencyOffset != that1.FrequencyOffset {
		return false
	}
	if this.SNR != that1.SNR {
		return false
	}
	if !bytes.Equal(this.EncryptedTime, that1.EncryptedTime) {
		return false
	}
	if this.FineTime != that1.FineTime {
		return false
	}
	return true
}
func (this *TxConfiguration) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TxConfiguration)
	if !ok {
		that2, ok := that.(TxConfiguration)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Timestamp != that1.Timestamp {
		return false
	}
	if this.RfChain != that1.RfChain {
		return false
	}
	if this.Frequency != that1.Frequency {
		return false
	}
	if this.Power != that1.Power {
		return false
	}
	if this.PolarizationInversion != that1.PolarizationInversion {
		return false
	}
	if this.FrequencyDeviation != that1.FrequencyDeviation {
		return false
	}
	return true
}
func (this *Status) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Status)
	if !ok {
		that2, ok := that.(Status)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Timestamp != that1.Timestamp {
		return false
	}
	if this.Time != that1.Time {
		return false
	}
	if this.GatewayTrusted != that1.GatewayTrusted {
		return false
	}
	if this.BootTime != that1.BootTime {
		return false
	}
	if len(this.IP) != len(that1.IP) {
		return false
	}
	for i := range this.IP {
		if this.IP[i] != that1.IP[i] {
			return false
		}
	}
	if this.Platform != that1.Platform {
		return false
	}
	if this.ContactEmail != that1.ContactEmail {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	if this.FrequencyPlan != that1.FrequencyPlan {
		return false
	}
	if this.Bridge != that1.Bridge {
		return false
	}
	if this.Router != that1.Router {
		return false
	}
	if this.FPGA != that1.FPGA {
		return false
	}
	if this.DSP != that1.DSP {
		return false
	}
	if this.HAL != that1.HAL {
		return false
	}
	if !this.Location.Equal(that1.Location) {
		return false
	}
	if this.RTT != that1.RTT {
		return false
	}
	if this.RxIn != that1.RxIn {
		return false
	}
	if this.RxOk != that1.RxOk {
		return false
	}
	if this.TxIn != that1.TxIn {
		return false
	}
	if this.TxOk != that1.TxOk {
		return false
	}
	if this.LmOk != that1.LmOk {
		return false
	}
	if this.LmSt != that1.LmSt {
		return false
	}
	if this.LmNw != that1.LmNw {
		return false
	}
	if this.LPPS != that1.LPPS {
		return false
	}
	if !this.OS.Equal(that1.OS) {
		return false
	}
	if len(this.Messages) != len(that1.Messages) {
		return false
	}
	for i := range this.Messages {
		if this.Messages[i] != that1.Messages[i] {
			return false
		}
	}
	return true
}
func (this *Status_OSMetrics) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Status_OSMetrics)
	if !ok {
		that2, ok := that.(Status_OSMetrics)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Load_1 != that1.Load_1 {
		return false
	}
	if this.Load_5 != that1.Load_5 {
		return false
	}
	if this.Load_15 != that1.Load_15 {
		return false
	}
	if this.CPUPercentage != that1.CPUPercentage {
		return false
	}
	if this.MemoryPercentage != that1.MemoryPercentage {
		return false
	}
	if this.Temperature != that1.Temperature {
		return false
	}
	return true
}
func (m *LocationMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LocationMetadata) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Time != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGateway(dAtA, i, uint64(m.Time))
	}
	if m.Latitude != 0 {
		dAtA[i] = 0x15
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Latitude))))
		i += 4
	}
	if m.Longitude != 0 {
		dAtA[i] = 0x1d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Longitude))))
		i += 4
	}
	if m.Altitude != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintGateway(dAtA, i, uint64(m.Altitude))
	}
	if m.Accuracy != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintGateway(dAtA, i, uint64(m.Accuracy))
	}
	if m.Source != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintGateway(dAtA, i, uint64(m.Source))
	}
	return i, nil
}

func (m *RxMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RxMetadata) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.GatewayID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGateway(dAtA, i, uint64(len(m.GatewayID)))
		i += copy(dAtA[i:], m.GatewayID)
	}
	if m.GatewayTrusted {
		dAtA[i] = 0x10
		i++
		if m.GatewayTrusted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Timestamp != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintGateway(dAtA, i, uint64(m.Timestamp))
	}
	if m.Time != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintGateway(dAtA, i, uint64(m.Time))
	}
	if len(m.EncryptedTime) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintGateway(dAtA, i, uint64(len(m.EncryptedTime)))
		i += copy(dAtA[i:], m.EncryptedTime)
	}
	if m.RfChain != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintGateway(dAtA, i, uint64(m.RfChain))
	}
	if m.Channel != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintGateway(dAtA, i, uint64(m.Channel))
	}
	if len(m.Antennas) > 0 {
		for _, msg := range m.Antennas {
			dAtA[i] = 0xf2
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintGateway(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Frequency != 0 {
		dAtA[i] = 0xf8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintGateway(dAtA, i, uint64(m.Frequency))
	}
	if m.RSSI != 0 {
		dAtA[i] = 0x85
		i++
		dAtA[i] = 0x2
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.RSSI))))
		i += 4
	}
	if m.SNR != 0 {
		dAtA[i] = 0x8d
		i++
		dAtA[i] = 0x2
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.SNR))))
		i += 4
	}
	if m.Location != nil {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintGateway(dAtA, i, uint64(m.Location.Size()))
		n1, err := m.Location.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *RxMetadata_Antenna) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RxMetadata_Antenna) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Antenna != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGateway(dAtA, i, uint64(m.Antenna))
	}
	if m.Channel != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGateway(dAtA, i, uint64(m.Channel))
	}
	if m.RSSI != 0 {
		dAtA[i] = 0x1d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.RSSI))))
		i += 4
	}
	if m.SNR != 0 {
		dAtA[i] = 0x25
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.SNR))))
		i += 4
	}
	if m.ChannelRSSI != 0 {
		dAtA[i] = 0x2d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.ChannelRSSI))))
		i += 4
	}
	if m.RSSIStandardDeviation != 0 {
		dAtA[i] = 0x35
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.RSSIStandardDeviation))))
		i += 4
	}
	if m.FrequencyOffset != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintGateway(dAtA, i, uint64(m.FrequencyOffset))
	}
	if len(m.EncryptedTime) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintGateway(dAtA, i, uint64(len(m.EncryptedTime)))
		i += copy(dAtA[i:], m.EncryptedTime)
	}
	if m.FineTime != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintGateway(dAtA, i, uint64(m.FineTime))
	}
	return i, nil
}

func (m *TxConfiguration) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxConfiguration) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Timestamp != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintGateway(dAtA, i, uint64(m.Timestamp))
	}
	if m.RfChain != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintGateway(dAtA, i, uint64(m.RfChain))
	}
	if m.Frequency != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintGateway(dAtA, i, uint64(m.Frequency))
	}
	if m.Power != 0 {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintGateway(dAtA, i, uint64(m.Power))
	}
	if m.PolarizationInversion {
		dAtA[i] = 0xf8
		i++
		dAtA[i] = 0x1
		i++
		if m.PolarizationInversion {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.FrequencyDeviation != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintGateway(dAtA, i, uint64(m.FrequencyDeviation))
	}
	return i, nil
}

func (m *Status) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Status) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Timestamp != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGateway(dAtA, i, uint64(m.Timestamp))
	}
	if m.Time != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGateway(dAtA, i, uint64(m.Time))
	}
	if m.GatewayTrusted {
		dAtA[i] = 0x18
		i++
		if m.GatewayTrusted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.BootTime != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintGateway(dAtA, i, uint64(m.BootTime))
	}
	if len(m.IP) > 0 {
		for _, s := range m.IP {
			dAtA[i] = 0x5a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Platform) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Platform)))
		i += copy(dAtA[i:], m.Platform)
	}
	if len(m.ContactEmail) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintGateway(dAtA, i, uint64(len(m.ContactEmail)))
		i += copy(dAtA[i:], m.ContactEmail)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if len(m.FrequencyPlan) > 0 {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintGateway(dAtA, i, uint64(len(m.FrequencyPlan)))
		i += copy(dAtA[i:], m.FrequencyPlan)
	}
	if len(m.Bridge) > 0 {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Bridge)))
		i += copy(dAtA[i:], m.Bridge)
	}
	if len(m.Router) > 0 {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Router)))
		i += copy(dAtA[i:], m.Router)
	}
	if m.FPGA != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintGateway(dAtA, i, uint64(m.FPGA))
	}
	if m.DSP != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintGateway(dAtA, i, uint64(m.DSP))
	}
	if len(m.HAL) > 0 {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintGateway(dAtA, i, uint64(len(m.HAL)))
		i += copy(dAtA[i:], m.HAL)
	}
	if m.Location != nil {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintGateway(dAtA, i, uint64(m.Location.Size()))
		n2, err := m.Location.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.RTT != 0 {
		dAtA[i] = 0xf8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintGateway(dAtA, i, uint64(m.RTT))
	}
	if m.RxIn != 0 {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintGateway(dAtA, i, uint64(m.RxIn))
	}
	if m.RxOk != 0 {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintGateway(dAtA, i, uint64(m.RxOk))
	}
	if m.TxIn != 0 {
		dAtA[i] = 0xd8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintGateway(dAtA, i, uint64(m.TxIn))
	}
	if m.TxOk != 0 {
		dAtA[i] = 0xe0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintGateway(dAtA, i, uint64(m.TxOk))
	}
	if m.LmOk != 0 {
		dAtA[i] = 0xe8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintGateway(dAtA, i, uint64(m.LmOk))
	}
	if m.LmSt != 0 {
		dAtA[i] = 0xf0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintGateway(dAtA, i, uint64(m.LmSt))
	}
	if m.LmNw != 0 {
		dAtA[i] = 0xf8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintGateway(dAtA, i, uint64(m.LmNw))
	}
	if m.LPPS != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintGateway(dAtA, i, uint64(m.LPPS))
	}
	if m.OS != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintGateway(dAtA, i, uint64(m.OS.Size()))
		n3, err := m.OS.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if len(m.Messages) > 0 {
		for _, s := range m.Messages {
			dAtA[i] = 0xa2
			i++
			dAtA[i] = 0x3
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *Status_OSMetrics) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Status_OSMetrics) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Load_1 != 0 {
		dAtA[i] = 0xd
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Load_1))))
		i += 4
	}
	if m.Load_5 != 0 {
		dAtA[i] = 0x15
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Load_5))))
		i += 4
	}
	if m.Load_15 != 0 {
		dAtA[i] = 0x1d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Load_15))))
		i += 4
	}
	if m.CPUPercentage != 0 {
		dAtA[i] = 0x5d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.CPUPercentage))))
		i += 4
	}
	if m.MemoryPercentage != 0 {
		dAtA[i] = 0xad
		i++
		dAtA[i] = 0x1
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.MemoryPercentage))))
		i += 4
	}
	if m.Temperature != 0 {
		dAtA[i] = 0xfd
		i++
		dAtA[i] = 0x1
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Temperature))))
		i += 4
	}
	return i, nil
}

func encodeVarintGateway(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func NewPopulatedLocationMetadata(r randyGateway, easy bool) *LocationMetadata {
	this := &LocationMetadata{}
	this.Time = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Time *= -1
	}
	this.Latitude = float32(r.Float32())
	if r.Intn(2) == 0 {
		this.Latitude *= -1
	}
	this.Longitude = float32(r.Float32())
	if r.Intn(2) == 0 {
		this.Longitude *= -1
	}
	this.Altitude = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.Altitude *= -1
	}
	this.Accuracy = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.Accuracy *= -1
	}
	this.Source = LocationMetadata_LocationSource([]int32{0, 1, 2, 3, 4}[r.Intn(5)])
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedRxMetadata(r randyGateway, easy bool) *RxMetadata {
	this := &RxMetadata{}
	this.GatewayID = string(randStringGateway(r))
	this.GatewayTrusted = bool(bool(r.Intn(2) == 0))
	this.Timestamp = uint32(r.Uint32())
	this.Time = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Time *= -1
	}
	v1 := r.Intn(100)
	this.EncryptedTime = make([]byte, v1)
	for i := 0; i < v1; i++ {
		this.EncryptedTime[i] = byte(r.Intn(256))
	}
	this.RfChain = uint32(r.Uint32())
	this.Channel = uint32(r.Uint32())
	if r.Intn(10) != 0 {
		v2 := r.Intn(5)
		this.Antennas = make([]*RxMetadata_Antenna, v2)
		for i := 0; i < v2; i++ {
			this.Antennas[i] = NewPopulatedRxMetadata_Antenna(r, easy)
		}
	}
	this.Frequency = uint64(uint64(r.Uint32()))
	this.RSSI = float32(r.Float32())
	if r.Intn(2) == 0 {
		this.RSSI *= -1
	}
	this.SNR = float32(r.Float32())
	if r.Intn(2) == 0 {
		this.SNR *= -1
	}
	if r.Intn(10) != 0 {
		this.Location = NewPopulatedLocationMetadata(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedRxMetadata_Antenna(r randyGateway, easy bool) *RxMetadata_Antenna {
	this := &RxMetadata_Antenna{}
	this.Antenna = uint32(r.Uint32())
	this.Channel = uint32(r.Uint32())
	this.RSSI = float32(r.Float32())
	if r.Intn(2) == 0 {
		this.RSSI *= -1
	}
	this.SNR = float32(r.Float32())
	if r.Intn(2) == 0 {
		this.SNR *= -1
	}
	this.ChannelRSSI = float32(r.Float32())
	if r.Intn(2) == 0 {
		this.ChannelRSSI *= -1
	}
	this.RSSIStandardDeviation = float32(r.Float32())
	if r.Intn(2) == 0 {
		this.RSSIStandardDeviation *= -1
	}
	this.FrequencyOffset = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.FrequencyOffset *= -1
	}
	v3 := r.Intn(100)
	this.EncryptedTime = make([]byte, v3)
	for i := 0; i < v3; i++ {
		this.EncryptedTime[i] = byte(r.Intn(256))
	}
	this.FineTime = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.FineTime *= -1
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedTxConfiguration(r randyGateway, easy bool) *TxConfiguration {
	this := &TxConfiguration{}
	this.Timestamp = uint32(r.Uint32())
	this.RfChain = uint32(r.Uint32())
	this.Frequency = uint64(uint64(r.Uint32()))
	this.Power = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.Power *= -1
	}
	this.PolarizationInversion = bool(bool(r.Intn(2) == 0))
	this.FrequencyDeviation = uint32(r.Uint32())
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedStatus(r randyGateway, easy bool) *Status {
	this := &Status{}
	this.Timestamp = uint32(r.Uint32())
	this.Time = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Time *= -1
	}
	this.GatewayTrusted = bool(bool(r.Intn(2) == 0))
	this.BootTime = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.BootTime *= -1
	}
	v4 := r.Intn(10)
	this.IP = make([]string, v4)
	for i := 0; i < v4; i++ {
		this.IP[i] = string(randStringGateway(r))
	}
	this.Platform = string(randStringGateway(r))
	this.ContactEmail = string(randStringGateway(r))
	this.Description = string(randStringGateway(r))
	this.FrequencyPlan = string(randStringGateway(r))
	this.Bridge = string(randStringGateway(r))
	this.Router = string(randStringGateway(r))
	this.FPGA = uint32(r.Uint32())
	this.DSP = uint32(r.Uint32())
	this.HAL = string(randStringGateway(r))
	if r.Intn(10) != 0 {
		this.Location = NewPopulatedLocationMetadata(r, easy)
	}
	this.RTT = uint32(r.Uint32())
	this.RxIn = uint32(r.Uint32())
	this.RxOk = uint32(r.Uint32())
	this.TxIn = uint32(r.Uint32())
	this.TxOk = uint32(r.Uint32())
	this.LmOk = uint32(r.Uint32())
	this.LmSt = uint32(r.Uint32())
	this.LmNw = uint32(r.Uint32())
	this.LPPS = uint32(r.Uint32())
	if r.Intn(10) != 0 {
		this.OS = NewPopulatedStatus_OSMetrics(r, easy)
	}
	v5 := r.Intn(10)
	this.Messages = make([]string, v5)
	for i := 0; i < v5; i++ {
		this.Messages[i] = string(randStringGateway(r))
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedStatus_OSMetrics(r randyGateway, easy bool) *Status_OSMetrics {
	this := &Status_OSMetrics{}
	this.Load_1 = float32(r.Float32())
	if r.Intn(2) == 0 {
		this.Load_1 *= -1
	}
	this.Load_5 = float32(r.Float32())
	if r.Intn(2) == 0 {
		this.Load_5 *= -1
	}
	this.Load_15 = float32(r.Float32())
	if r.Intn(2) == 0 {
		this.Load_15 *= -1
	}
	this.CPUPercentage = float32(r.Float32())
	if r.Intn(2) == 0 {
		this.CPUPercentage *= -1
	}
	this.MemoryPercentage = float32(r.Float32())
	if r.Intn(2) == 0 {
		this.MemoryPercentage *= -1
	}
	this.Temperature = float32(r.Float32())
	if r.Intn(2) == 0 {
		this.Temperature *= -1
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

type randyGateway interface {
	Float32() float32
	Float64() float64
	Int63() int64
	Int31() int32
	Uint32() uint32
	Intn(n int) int
}

func randUTF8RuneGateway(r randyGateway) rune {
	ru := r.Intn(62)
	if ru < 10 {
		return rune(ru + 48)
	} else if ru < 36 {
		return rune(ru + 55)
	}
	return rune(ru + 61)
}
func randStringGateway(r randyGateway) string {
	v6 := r.Intn(100)
	tmps := make([]rune, v6)
	for i := 0; i < v6; i++ {
		tmps[i] = randUTF8RuneGateway(r)
	}
	return string(tmps)
}
func randUnrecognizedGateway(r randyGateway, maxFieldNumber int) (dAtA []byte) {
	l := r.Intn(5)
	for i := 0; i < l; i++ {
		wire := r.Intn(4)
		if wire == 3 {
			wire = 5
		}
		fieldNumber := maxFieldNumber + r.Intn(100)
		dAtA = randFieldGateway(dAtA, r, fieldNumber, wire)
	}
	return dAtA
}
func randFieldGateway(dAtA []byte, r randyGateway, fieldNumber int, wire int) []byte {
	key := uint32(fieldNumber)<<3 | uint32(wire)
	switch wire {
	case 0:
		dAtA = encodeVarintPopulateGateway(dAtA, uint64(key))
		v7 := r.Int63()
		if r.Intn(2) == 0 {
			v7 *= -1
		}
		dAtA = encodeVarintPopulateGateway(dAtA, uint64(v7))
	case 1:
		dAtA = encodeVarintPopulateGateway(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	case 2:
		dAtA = encodeVarintPopulateGateway(dAtA, uint64(key))
		ll := r.Intn(100)
		dAtA = encodeVarintPopulateGateway(dAtA, uint64(ll))
		for j := 0; j < ll; j++ {
			dAtA = append(dAtA, byte(r.Intn(256)))
		}
	default:
		dAtA = encodeVarintPopulateGateway(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	}
	return dAtA
}
func encodeVarintPopulateGateway(dAtA []byte, v uint64) []byte {
	for v >= 1<<7 {
		dAtA = append(dAtA, uint8(uint64(v)&0x7f|0x80))
		v >>= 7
	}
	dAtA = append(dAtA, uint8(v))
	return dAtA
}
func (m *LocationMetadata) Size() (n int) {
	var l int
	_ = l
	if m.Time != 0 {
		n += 1 + sovGateway(uint64(m.Time))
	}
	if m.Latitude != 0 {
		n += 5
	}
	if m.Longitude != 0 {
		n += 5
	}
	if m.Altitude != 0 {
		n += 1 + sovGateway(uint64(m.Altitude))
	}
	if m.Accuracy != 0 {
		n += 1 + sovGateway(uint64(m.Accuracy))
	}
	if m.Source != 0 {
		n += 1 + sovGateway(uint64(m.Source))
	}
	return n
}

func (m *RxMetadata) Size() (n int) {
	var l int
	_ = l
	l = len(m.GatewayID)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.GatewayTrusted {
		n += 2
	}
	if m.Timestamp != 0 {
		n += 1 + sovGateway(uint64(m.Timestamp))
	}
	if m.Time != 0 {
		n += 1 + sovGateway(uint64(m.Time))
	}
	l = len(m.EncryptedTime)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.RfChain != 0 {
		n += 2 + sovGateway(uint64(m.RfChain))
	}
	if m.Channel != 0 {
		n += 2 + sovGateway(uint64(m.Channel))
	}
	if len(m.Antennas) > 0 {
		for _, e := range m.Antennas {
			l = e.Size()
			n += 2 + l + sovGateway(uint64(l))
		}
	}
	if m.Frequency != 0 {
		n += 2 + sovGateway(uint64(m.Frequency))
	}
	if m.RSSI != 0 {
		n += 6
	}
	if m.SNR != 0 {
		n += 6
	}
	if m.Location != nil {
		l = m.Location.Size()
		n += 2 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *RxMetadata_Antenna) Size() (n int) {
	var l int
	_ = l
	if m.Antenna != 0 {
		n += 1 + sovGateway(uint64(m.Antenna))
	}
	if m.Channel != 0 {
		n += 1 + sovGateway(uint64(m.Channel))
	}
	if m.RSSI != 0 {
		n += 5
	}
	if m.SNR != 0 {
		n += 5
	}
	if m.ChannelRSSI != 0 {
		n += 5
	}
	if m.RSSIStandardDeviation != 0 {
		n += 5
	}
	if m.FrequencyOffset != 0 {
		n += 1 + sovGateway(uint64(m.FrequencyOffset))
	}
	l = len(m.EncryptedTime)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.FineTime != 0 {
		n += 1 + sovGateway(uint64(m.FineTime))
	}
	return n
}

func (m *TxConfiguration) Size() (n int) {
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovGateway(uint64(m.Timestamp))
	}
	if m.RfChain != 0 {
		n += 2 + sovGateway(uint64(m.RfChain))
	}
	if m.Frequency != 0 {
		n += 2 + sovGateway(uint64(m.Frequency))
	}
	if m.Power != 0 {
		n += 2 + sovGateway(uint64(m.Power))
	}
	if m.PolarizationInversion {
		n += 3
	}
	if m.FrequencyDeviation != 0 {
		n += 2 + sovGateway(uint64(m.FrequencyDeviation))
	}
	return n
}

func (m *Status) Size() (n int) {
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovGateway(uint64(m.Timestamp))
	}
	if m.Time != 0 {
		n += 1 + sovGateway(uint64(m.Time))
	}
	if m.GatewayTrusted {
		n += 2
	}
	if m.BootTime != 0 {
		n += 1 + sovGateway(uint64(m.BootTime))
	}
	if len(m.IP) > 0 {
		for _, s := range m.IP {
			l = len(s)
			n += 1 + l + sovGateway(uint64(l))
		}
	}
	l = len(m.Platform)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.ContactEmail)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.FrequencyPlan)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.Bridge)
	if l > 0 {
		n += 2 + l + sovGateway(uint64(l))
	}
	l = len(m.Router)
	if l > 0 {
		n += 2 + l + sovGateway(uint64(l))
	}
	if m.FPGA != 0 {
		n += 2 + sovGateway(uint64(m.FPGA))
	}
	if m.DSP != 0 {
		n += 2 + sovGateway(uint64(m.DSP))
	}
	l = len(m.HAL)
	if l > 0 {
		n += 2 + l + sovGateway(uint64(l))
	}
	if m.Location != nil {
		l = m.Location.Size()
		n += 2 + l + sovGateway(uint64(l))
	}
	if m.RTT != 0 {
		n += 2 + sovGateway(uint64(m.RTT))
	}
	if m.RxIn != 0 {
		n += 2 + sovGateway(uint64(m.RxIn))
	}
	if m.RxOk != 0 {
		n += 2 + sovGateway(uint64(m.RxOk))
	}
	if m.TxIn != 0 {
		n += 2 + sovGateway(uint64(m.TxIn))
	}
	if m.TxOk != 0 {
		n += 2 + sovGateway(uint64(m.TxOk))
	}
	if m.LmOk != 0 {
		n += 2 + sovGateway(uint64(m.LmOk))
	}
	if m.LmSt != 0 {
		n += 2 + sovGateway(uint64(m.LmSt))
	}
	if m.LmNw != 0 {
		n += 2 + sovGateway(uint64(m.LmNw))
	}
	if m.LPPS != 0 {
		n += 2 + sovGateway(uint64(m.LPPS))
	}
	if m.OS != nil {
		l = m.OS.Size()
		n += 2 + l + sovGateway(uint64(l))
	}
	if len(m.Messages) > 0 {
		for _, s := range m.Messages {
			l = len(s)
			n += 2 + l + sovGateway(uint64(l))
		}
	}
	return n
}

func (m *Status_OSMetrics) Size() (n int) {
	var l int
	_ = l
	if m.Load_1 != 0 {
		n += 5
	}
	if m.Load_5 != 0 {
		n += 5
	}
	if m.Load_15 != 0 {
		n += 5
	}
	if m.CPUPercentage != 0 {
		n += 5
	}
	if m.MemoryPercentage != 0 {
		n += 6
	}
	if m.Temperature != 0 {
		n += 6
	}
	return n
}

func sovGateway(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozGateway(x uint64) (n int) {
	return sovGateway(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *LocationMetadata) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LocationMetadata{`,
		`Time:` + fmt.Sprintf("%v", this.Time) + `,`,
		`Latitude:` + fmt.Sprintf("%v", this.Latitude) + `,`,
		`Longitude:` + fmt.Sprintf("%v", this.Longitude) + `,`,
		`Altitude:` + fmt.Sprintf("%v", this.Altitude) + `,`,
		`Accuracy:` + fmt.Sprintf("%v", this.Accuracy) + `,`,
		`Source:` + fmt.Sprintf("%v", this.Source) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RxMetadata) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RxMetadata{`,
		`GatewayID:` + fmt.Sprintf("%v", this.GatewayID) + `,`,
		`GatewayTrusted:` + fmt.Sprintf("%v", this.GatewayTrusted) + `,`,
		`Timestamp:` + fmt.Sprintf("%v", this.Timestamp) + `,`,
		`Time:` + fmt.Sprintf("%v", this.Time) + `,`,
		`EncryptedTime:` + fmt.Sprintf("%v", this.EncryptedTime) + `,`,
		`RfChain:` + fmt.Sprintf("%v", this.RfChain) + `,`,
		`Channel:` + fmt.Sprintf("%v", this.Channel) + `,`,
		`Antennas:` + strings.Replace(fmt.Sprintf("%v", this.Antennas), "RxMetadata_Antenna", "RxMetadata_Antenna", 1) + `,`,
		`Frequency:` + fmt.Sprintf("%v", this.Frequency) + `,`,
		`RSSI:` + fmt.Sprintf("%v", this.RSSI) + `,`,
		`SNR:` + fmt.Sprintf("%v", this.SNR) + `,`,
		`Location:` + strings.Replace(fmt.Sprintf("%v", this.Location), "LocationMetadata", "LocationMetadata", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RxMetadata_Antenna) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RxMetadata_Antenna{`,
		`Antenna:` + fmt.Sprintf("%v", this.Antenna) + `,`,
		`Channel:` + fmt.Sprintf("%v", this.Channel) + `,`,
		`RSSI:` + fmt.Sprintf("%v", this.RSSI) + `,`,
		`SNR:` + fmt.Sprintf("%v", this.SNR) + `,`,
		`ChannelRSSI:` + fmt.Sprintf("%v", this.ChannelRSSI) + `,`,
		`RSSIStandardDeviation:` + fmt.Sprintf("%v", this.RSSIStandardDeviation) + `,`,
		`FrequencyOffset:` + fmt.Sprintf("%v", this.FrequencyOffset) + `,`,
		`EncryptedTime:` + fmt.Sprintf("%v", this.EncryptedTime) + `,`,
		`FineTime:` + fmt.Sprintf("%v", this.FineTime) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TxConfiguration) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TxConfiguration{`,
		`Timestamp:` + fmt.Sprintf("%v", this.Timestamp) + `,`,
		`RfChain:` + fmt.Sprintf("%v", this.RfChain) + `,`,
		`Frequency:` + fmt.Sprintf("%v", this.Frequency) + `,`,
		`Power:` + fmt.Sprintf("%v", this.Power) + `,`,
		`PolarizationInversion:` + fmt.Sprintf("%v", this.PolarizationInversion) + `,`,
		`FrequencyDeviation:` + fmt.Sprintf("%v", this.FrequencyDeviation) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Status) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Status{`,
		`Timestamp:` + fmt.Sprintf("%v", this.Timestamp) + `,`,
		`Time:` + fmt.Sprintf("%v", this.Time) + `,`,
		`GatewayTrusted:` + fmt.Sprintf("%v", this.GatewayTrusted) + `,`,
		`BootTime:` + fmt.Sprintf("%v", this.BootTime) + `,`,
		`IP:` + fmt.Sprintf("%v", this.IP) + `,`,
		`Platform:` + fmt.Sprintf("%v", this.Platform) + `,`,
		`ContactEmail:` + fmt.Sprintf("%v", this.ContactEmail) + `,`,
		`Description:` + fmt.Sprintf("%v", this.Description) + `,`,
		`FrequencyPlan:` + fmt.Sprintf("%v", this.FrequencyPlan) + `,`,
		`Bridge:` + fmt.Sprintf("%v", this.Bridge) + `,`,
		`Router:` + fmt.Sprintf("%v", this.Router) + `,`,
		`FPGA:` + fmt.Sprintf("%v", this.FPGA) + `,`,
		`DSP:` + fmt.Sprintf("%v", this.DSP) + `,`,
		`HAL:` + fmt.Sprintf("%v", this.HAL) + `,`,
		`Location:` + strings.Replace(fmt.Sprintf("%v", this.Location), "LocationMetadata", "LocationMetadata", 1) + `,`,
		`RTT:` + fmt.Sprintf("%v", this.RTT) + `,`,
		`RxIn:` + fmt.Sprintf("%v", this.RxIn) + `,`,
		`RxOk:` + fmt.Sprintf("%v", this.RxOk) + `,`,
		`TxIn:` + fmt.Sprintf("%v", this.TxIn) + `,`,
		`TxOk:` + fmt.Sprintf("%v", this.TxOk) + `,`,
		`LmOk:` + fmt.Sprintf("%v", this.LmOk) + `,`,
		`LmSt:` + fmt.Sprintf("%v", this.LmSt) + `,`,
		`LmNw:` + fmt.Sprintf("%v", this.LmNw) + `,`,
		`LPPS:` + fmt.Sprintf("%v", this.LPPS) + `,`,
		`OS:` + strings.Replace(fmt.Sprintf("%v", this.OS), "Status_OSMetrics", "Status_OSMetrics", 1) + `,`,
		`Messages:` + fmt.Sprintf("%v", this.Messages) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Status_OSMetrics) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Status_OSMetrics{`,
		`Load_1:` + fmt.Sprintf("%v", this.Load_1) + `,`,
		`Load_5:` + fmt.Sprintf("%v", this.Load_5) + `,`,
		`Load_15:` + fmt.Sprintf("%v", this.Load_15) + `,`,
		`CPUPercentage:` + fmt.Sprintf("%v", this.CPUPercentage) + `,`,
		`MemoryPercentage:` + fmt.Sprintf("%v", this.MemoryPercentage) + `,`,
		`Temperature:` + fmt.Sprintf("%v", this.Temperature) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringGateway(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *LocationMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LocationMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LocationMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Latitude", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Latitude = float32(math.Float32frombits(v))
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Longitude", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Longitude = float32(math.Float32frombits(v))
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Altitude", wireType)
			}
			m.Altitude = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Altitude |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Accuracy", wireType)
			}
			m.Accuracy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Accuracy |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			m.Source = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Source |= (LocationMetadata_LocationSource(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RxMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RxMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RxMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GatewayID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GatewayID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GatewayTrusted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.GatewayTrusted = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptedTime", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncryptedTime = append(m.EncryptedTime[:0], dAtA[iNdEx:postIndex]...)
			if m.EncryptedTime == nil {
				m.EncryptedTime = []byte{}
			}
			iNdEx = postIndex
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RfChain", wireType)
			}
			m.RfChain = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RfChain |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			m.Channel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Channel |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Antennas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Antennas = append(m.Antennas, &RxMetadata_Antenna{})
			if err := m.Antennas[len(m.Antennas)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Frequency", wireType)
			}
			m.Frequency = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Frequency |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 32:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field RSSI", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.RSSI = float32(math.Float32frombits(v))
		case 33:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field SNR", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.SNR = float32(math.Float32frombits(v))
		case 41:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &LocationMetadata{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RxMetadata_Antenna) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Antenna: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Antenna: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Antenna", wireType)
			}
			m.Antenna = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Antenna |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			m.Channel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Channel |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field RSSI", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.RSSI = float32(math.Float32frombits(v))
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field SNR", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.SNR = float32(math.Float32frombits(v))
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelRSSI", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.ChannelRSSI = float32(math.Float32frombits(v))
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field RSSIStandardDeviation", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.RSSIStandardDeviation = float32(math.Float32frombits(v))
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FrequencyOffset", wireType)
			}
			m.FrequencyOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FrequencyOffset |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptedTime", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncryptedTime = append(m.EncryptedTime[:0], dAtA[iNdEx:postIndex]...)
			if m.EncryptedTime == nil {
				m.EncryptedTime = []byte{}
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FineTime", wireType)
			}
			m.FineTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FineTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxConfiguration) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxConfiguration: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxConfiguration: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RfChain", wireType)
			}
			m.RfChain = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RfChain |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Frequency", wireType)
			}
			m.Frequency = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Frequency |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Power", wireType)
			}
			m.Power = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Power |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PolarizationInversion", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PolarizationInversion = bool(v != 0)
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FrequencyDeviation", wireType)
			}
			m.FrequencyDeviation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FrequencyDeviation |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Status) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Status: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Status: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GatewayTrusted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.GatewayTrusted = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BootTime", wireType)
			}
			m.BootTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BootTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IP = append(m.IP, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Platform", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Platform = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContactEmail", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContactEmail = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FrequencyPlan", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FrequencyPlan = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bridge", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bridge = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Router", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Router = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FPGA", wireType)
			}
			m.FPGA = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FPGA |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DSP", wireType)
			}
			m.DSP = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DSP |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HAL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HAL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &LocationMetadata{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RTT", wireType)
			}
			m.RTT = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RTT |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 41:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RxIn", wireType)
			}
			m.RxIn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RxIn |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 42:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RxOk", wireType)
			}
			m.RxOk = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RxOk |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 43:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxIn", wireType)
			}
			m.TxIn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxIn |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 44:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxOk", wireType)
			}
			m.TxOk = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxOk |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 45:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LmOk", wireType)
			}
			m.LmOk = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LmOk |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 46:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LmSt", wireType)
			}
			m.LmSt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LmSt |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 47:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LmNw", wireType)
			}
			m.LmNw = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LmNw |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 48:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LPPS", wireType)
			}
			m.LPPS = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LPPS |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 51:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OS", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OS == nil {
				m.OS = &Status_OSMetrics{}
			}
			if err := m.OS.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 52:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Messages", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Messages = append(m.Messages, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Status_OSMetrics) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OSMetrics: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OSMetrics: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Load_1", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Load_1 = float32(math.Float32frombits(v))
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Load_5", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Load_5 = float32(math.Float32frombits(v))
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Load_15", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Load_15 = float32(math.Float32frombits(v))
		case 11:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field CPUPercentage", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.CPUPercentage = float32(math.Float32frombits(v))
		case 21:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoryPercentage", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.MemoryPercentage = float32(math.Float32frombits(v))
		case 31:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Temperature", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Temperature = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipGateway(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthGateway
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowGateway
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipGateway(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthGateway = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowGateway   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("github.com/TheThingsNetwork/api/gateway/gateway.proto", fileDescriptor_gateway_cd729bb602de8f80)
}
func init() {
	golang_proto.RegisterFile("github.com/TheThingsNetwork/api/gateway/gateway.proto", fileDescriptor_gateway_cd729bb602de8f80)
}

var fileDescriptor_gateway_cd729bb602de8f80 = []byte{
	// 1368 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x96, 0x3f, 0x6c, 0x1b, 0x37,
	0x14, 0xc6, 0x8f, 0x27, 0x59, 0x7f, 0x28, 0xcb, 0x56, 0x98, 0xd8, 0x39, 0x3b, 0x29, 0xa5, 0xba,
	0x28, 0xa2, 0x34, 0x89, 0x5c, 0x3b, 0x35, 0xda, 0xb1, 0xb6, 0x93, 0xb8, 0x42, 0x1d, 0x49, 0xa5,
	0x14, 0x14, 0xed, 0x22, 0xd0, 0x27, 0x4a, 0x3e, 0xe4, 0x74, 0x77, 0xe5, 0x51, 0xb1, 0xdd, 0x29,
	0x63, 0xc6, 0x8e, 0x1d, 0xbb, 0x35, 0xe8, 0x94, 0x31, 0x63, 0xc6, 0x8c, 0xd9, 0x1a, 0xa0, 0x80,
	0x11, 0x9d, 0x80, 0x22, 0x43, 0x51, 0x64, 0xcc, 0x58, 0x90, 0x77, 0x3a, 0xc9, 0xae, 0x13, 0x64,
	0x92, 0xde, 0xef, 0x7d, 0xe4, 0x91, 0x1f, 0x1f, 0x1f, 0x08, 0x37, 0x7a, 0x96, 0xd8, 0x1f, 0xec,
	0x55, 0x4c, 0xb7, 0xbf, 0xda, 0xda, 0x67, 0xad, 0x7d, 0xcb, 0xe9, 0xf9, 0x35, 0x26, 0x0e, 0x5c,
	0x7e, 0x7f, 0x95, 0x7a, 0xd6, 0x6a, 0x8f, 0x0a, 0x76, 0x40, 0x8f, 0xc6, 0xbf, 0x15, 0x8f, 0xbb,
	0xc2, 0x45, 0xe9, 0x28, 0x5c, 0xbe, 0x31, 0x35, 0xbe, 0xe7, 0xf6, 0xdc, 0x55, 0x95, 0xdf, 0x1b,
	0x74, 0x55, 0xa4, 0x02, 0xf5, 0x2f, 0x1c, 0xb7, 0xf2, 0x44, 0x87, 0x85, 0x5d, 0xd7, 0xa4, 0xc2,
	0x72, 0x9d, 0xbb, 0x4c, 0xd0, 0x0e, 0x15, 0x14, 0x21, 0x98, 0x14, 0x56, 0x9f, 0x19, 0xa0, 0x04,
	0xca, 0x09, 0xa2, 0xfe, 0xa3, 0x65, 0x98, 0xb1, 0xa9, 0xb0, 0xc4, 0xa0, 0xc3, 0x0c, 0xbd, 0x04,
	0xca, 0x3a, 0x89, 0x63, 0x74, 0x19, 0x66, 0x6d, 0xd7, 0xe9, 0x85, 0xc9, 0x84, 0x4a, 0x4e, 0x80,
	0x1c, 0x49, 0xed, 0x68, 0x64, 0xb2, 0x04, 0xca, 0x33, 0x24, 0x8e, 0x55, 0xce, 0x34, 0x07, 0x9c,
	0x9a, 0x47, 0xc6, 0x4c, 0x94, 0x8b, 0x62, 0xf4, 0x35, 0x4c, 0xf9, 0xee, 0x80, 0x9b, 0xcc, 0x48,
	0x95, 0x40, 0x79, 0x6e, 0xbd, 0x5c, 0x19, 0x6f, 0xf9, 0xf4, 0x82, 0x63, 0xd0, 0x54, 0x7a, 0x12,
	0x8d, 0x5b, 0x69, 0xc1, 0xb9, 0x93, 0x19, 0x94, 0x83, 0xe9, 0x7b, 0xb5, 0x6f, 0x6b, 0xf5, 0xef,
	0x6b, 0x05, 0x0d, 0xa5, 0x61, 0x62, 0xa7, 0xd1, 0x2c, 0x00, 0x04, 0x61, 0x6a, 0xbb, 0x5e, 0xbb,
	0x53, 0xdd, 0x29, 0xe8, 0x68, 0x16, 0x66, 0xc8, 0xed, 0x9d, 0x6a, 0xb3, 0x45, 0x7e, 0x28, 0x24,
	0x10, 0x82, 0x73, 0xd5, 0x46, 0x7b, 0xe7, 0x76, 0x7d, 0xb7, 0xbe, 0xbd, 0xd9, 0xaa, 0xd6, 0x6b,
	0x85, 0xe4, 0xca, 0xef, 0x29, 0x08, 0xc9, 0x61, 0x6c, 0xd6, 0x75, 0x08, 0xa3, 0x75, 0xb5, 0xad,
	0x8e, 0xb2, 0x2c, 0xbb, 0x95, 0x0f, 0x8e, 0x8b, 0xd9, 0x9d, 0x90, 0x56, 0x6f, 0x91, 0x6c, 0x24,
	0xa8, 0x76, 0xd0, 0x15, 0x38, 0x3f, 0x56, 0x0b, 0x3e, 0xf0, 0x05, 0xeb, 0x28, 0x37, 0x33, 0x64,
	0x2e, 0xc2, 0xad, 0x90, 0x4a, 0x4f, 0xa5, 0xef, 0xbe, 0xa0, 0x7d, 0xcf, 0xc8, 0x95, 0x40, 0x39,
	0x4f, 0x26, 0x20, 0x3e, 0xa1, 0xd9, 0xa9, 0x13, 0xfa, 0x14, 0xce, 0x31, 0xc7, 0xe4, 0x47, 0x9e,
	0x60, 0x9d, 0xb6, 0xca, 0xe6, 0x4b, 0xa0, 0x3c, 0x4b, 0xf2, 0x31, 0x6d, 0x49, 0xd9, 0x12, 0xcc,
	0xf0, 0x6e, 0xdb, 0xdc, 0xa7, 0x96, 0x63, 0x2c, 0xa8, 0x79, 0xd3, 0xbc, 0xbb, 0x2d, 0x43, 0x64,
	0xc0, 0xb4, 0xb9, 0x4f, 0x1d, 0x87, 0xd9, 0xc6, 0x62, 0x98, 0x89, 0x42, 0xf4, 0x25, 0xcc, 0x50,
	0x47, 0x30, 0xc7, 0xa1, 0xbe, 0x81, 0x4b, 0x89, 0x72, 0x6e, 0xfd, 0x52, 0x7c, 0x1a, 0x13, 0x2f,
	0x2a, 0x9b, 0xa1, 0x86, 0xc4, 0x62, 0xb9, 0x8d, 0x2e, 0x67, 0x3f, 0x0d, 0x98, 0x63, 0x1e, 0x19,
	0xc5, 0x12, 0x28, 0x27, 0xc9, 0x04, 0xa0, 0xcb, 0x30, 0xc9, 0x7d, 0xdf, 0x32, 0x4a, 0xb2, 0x66,
	0xb6, 0x32, 0xc1, 0x71, 0x31, 0x49, 0x9a, 0xcd, 0x2a, 0x51, 0x14, 0x2d, 0xc1, 0x84, 0xef, 0x70,
	0xe3, 0x63, 0x95, 0x4c, 0x07, 0xc7, 0xc5, 0x44, 0xb3, 0x46, 0x88, 0x64, 0x68, 0x03, 0x66, 0xec,
	0xe8, 0x64, 0x8d, 0xab, 0x25, 0x50, 0xce, 0xad, 0x2f, 0xbd, 0xb3, 0x3a, 0x48, 0x2c, 0x5d, 0xfe,
	0x47, 0x87, 0xe9, 0x68, 0x8d, 0x72, 0xb3, 0xd1, 0x2a, 0xd5, 0xa1, 0xe5, 0xc9, 0x38, 0x9c, 0xb6,
	0x41, 0x3f, 0x69, 0xc3, 0x78, 0xbd, 0x89, 0xf7, 0xad, 0x37, 0x79, 0xc6, 0x7a, 0xd7, 0xe1, 0x6c,
	0x34, 0x47, 0x5b, 0x4d, 0x30, 0xa3, 0x34, 0xf3, 0xc1, 0x71, 0x31, 0xb7, 0x1d, 0x72, 0x35, 0x4f,
	0x2e, 0x12, 0x11, 0x39, 0xdd, 0x77, 0xf0, 0xa2, 0xd4, 0xb6, 0x7d, 0x41, 0x9d, 0x0e, 0xe5, 0x9d,
	0x76, 0x87, 0x3d, 0xb0, 0xc2, 0x2d, 0xa7, 0xd4, 0xf0, 0xa5, 0xe0, 0xb8, 0xb8, 0x20, 0xc7, 0x35,
	0x23, 0xc5, 0xad, 0xb1, 0x80, 0x2c, 0xc8, 0x91, 0xff, 0xc3, 0xe8, 0x2a, 0x2c, 0xc4, 0xe6, 0xb7,
	0xdd, 0x6e, 0xd7, 0x67, 0xc2, 0x48, 0xab, 0x12, 0x9a, 0x8f, 0x79, 0x5d, 0xe1, 0x33, 0xaa, 0x09,
	0x9e, 0x55, 0x4d, 0x97, 0x60, 0xb6, 0x6b, 0x39, 0x2c, 0x54, 0xe4, 0xd4, 0x54, 0x19, 0x09, 0x64,
	0x72, 0xe5, 0x6f, 0x00, 0xe7, 0x5b, 0x87, 0xdb, 0xae, 0xd3, 0xb5, 0x7a, 0x03, 0x1e, 0x2e, 0xe1,
	0xfd, 0x75, 0xfd, 0x9e, 0xe2, 0x3c, 0x51, 0x49, 0x8b, 0xa7, 0x2b, 0xe9, 0x02, 0x9c, 0xf1, 0xdc,
	0x03, 0xc6, 0x8d, 0x8b, 0xaa, 0x8b, 0x84, 0x01, 0xda, 0x80, 0x8b, 0x9e, 0x6b, 0x53, 0x6e, 0xfd,
	0xac, 0x3e, 0xde, 0xb6, 0x9c, 0x07, 0x8c, 0xfb, 0xd2, 0xc1, 0xa2, 0xba, 0x74, 0x0b, 0xd3, 0xd9,
	0xea, 0x38, 0x89, 0x56, 0xe1, 0xf9, 0x89, 0x4d, 0x13, 0xd7, 0x4b, 0x6a, 0x41, 0x28, 0x4e, 0xc5,
	0xbe, 0xae, 0xfc, 0x99, 0x86, 0xa9, 0xa6, 0xa0, 0x62, 0xe0, 0x9f, 0xdc, 0x1f, 0x78, 0xd7, 0xbd,
	0xd5, 0xa7, 0xee, 0xed, 0x19, 0x2d, 0x21, 0x71, 0x66, 0x4b, 0xb8, 0x04, 0xb3, 0x7b, 0xae, 0x2b,
	0x42, 0xaf, 0x93, 0xa1, 0xd7, 0x12, 0xa8, 0x83, 0x58, 0x84, 0xba, 0x25, 0x0d, 0x4d, 0x94, 0xb3,
	0x5b, 0xa9, 0xe0, 0xb8, 0xa8, 0x57, 0x1b, 0x44, 0xb7, 0x3c, 0xd9, 0x61, 0x3d, 0x9b, 0x8a, 0xae,
	0xcb, 0xfb, 0xaa, 0x5b, 0x64, 0x49, 0x1c, 0xa3, 0x4f, 0x60, 0xde, 0x74, 0x1d, 0x41, 0x4d, 0xd1,
	0x66, 0x7d, 0x6a, 0xd9, 0xaa, 0x61, 0x64, 0xc9, 0x6c, 0x04, 0x6f, 0x4b, 0x86, 0x4a, 0x30, 0xd7,
	0x61, 0xbe, 0xc9, 0x2d, 0x4f, 0x99, 0x30, 0xa7, 0x24, 0xd3, 0x48, 0x96, 0xca, 0xc4, 0x2e, 0xcf,
	0xa6, 0x8e, 0x31, 0xaf, 0x44, 0xf9, 0x98, 0x36, 0x6c, 0xea, 0xa0, 0x45, 0x98, 0xda, 0xe3, 0x56,
	0xa7, 0xc7, 0x8c, 0x82, 0x4a, 0x47, 0x91, 0xe4, 0xdc, 0x1d, 0x08, 0xc6, 0x8d, 0x73, 0x21, 0x0f,
	0x23, 0x79, 0xd9, 0xba, 0x5e, 0x8f, 0x1a, 0x48, 0x9a, 0x18, 0x5e, 0xb6, 0x3b, 0x8d, 0x9d, 0x4d,
	0xa2, 0xa8, 0xbc, 0x6c, 0x1d, 0xdf, 0x33, 0xce, 0xab, 0xa4, 0xba, 0x6c, 0xb7, 0x9a, 0x0d, 0x22,
	0x99, 0x4c, 0xed, 0x53, 0xdb, 0xb8, 0xa0, 0x5a, 0xb1, 0x4a, 0x7d, 0xb3, 0xb9, 0x4b, 0x24, 0x3b,
	0xd1, 0x37, 0x16, 0x3e, 0xb8, 0x6f, 0xc8, 0x19, 0xb9, 0x10, 0xaa, 0x68, 0xa2, 0x8f, 0x91, 0x56,
	0x8b, 0x48, 0x86, 0xce, 0xc3, 0x19, 0x7e, 0xd8, 0xb6, 0xc2, 0x36, 0x94, 0x27, 0x49, 0x7e, 0x58,
	0x75, 0x22, 0xe8, 0xde, 0x37, 0x3e, 0x1b, 0xc3, 0xfa, 0x7d, 0x09, 0x85, 0x52, 0x5e, 0x0b, 0xa1,
	0x88, 0x94, 0x42, 0x29, 0xaf, 0x8f, 0x61, 0xa8, 0xb4, 0xfb, 0x12, 0xde, 0x08, 0xa1, 0xdd, 0x8f,
	0xa1, 0x2f, 0x8c, 0xca, 0x18, 0x36, 0x45, 0x04, 0x9d, 0x03, 0x63, 0x75, 0x0c, 0x6b, 0x07, 0xe8,
	0x23, 0x38, 0x63, 0xb7, 0x3d, 0xcf, 0x37, 0x3e, 0x9f, 0x38, 0xb7, 0xdb, 0x68, 0x34, 0x49, 0xd2,
	0x6e, 0x78, 0x3e, 0x5a, 0x83, 0xba, 0xeb, 0x1b, 0x37, 0x4f, 0xed, 0x3e, 0x2c, 0xdf, 0x4a, 0xbd,
	0x79, 0x97, 0x09, 0x6e, 0x99, 0x7e, 0x58, 0x44, 0xf5, 0x26, 0xd1, 0x5d, 0x5f, 0x16, 0x51, 0x9f,
	0xf9, 0x3e, 0xed, 0x31, 0xdf, 0xf8, 0x42, 0x96, 0x18, 0x89, 0xe3, 0xe5, 0xbf, 0x00, 0xcc, 0xc6,
	0xa3, 0xd0, 0x02, 0x4c, 0xd9, 0x2e, 0xed, 0xb4, 0xd7, 0x54, 0xed, 0xeb, 0x64, 0x46, 0x46, 0x6b,
	0x31, 0xde, 0x88, 0xde, 0x0e, 0x0a, 0x6f, 0xa0, 0x8b, 0x30, 0x1d, 0xaa, 0x37, 0xa2, 0x67, 0x83,
	0x52, 0xad, 0x6d, 0xa0, 0xaf, 0xe0, 0x9c, 0xe9, 0x0d, 0xda, 0x1e, 0xe3, 0x26, 0x73, 0x04, 0xed,
	0x85, 0xbd, 0x45, 0xdf, 0x3a, 0x17, 0x1c, 0x17, 0xf3, 0xdb, 0x8d, 0x7b, 0x8d, 0x38, 0x41, 0xf2,
	0xa6, 0x37, 0x98, 0x84, 0xe8, 0x1a, 0x3c, 0xd7, 0x67, 0x7d, 0x97, 0x1f, 0x4d, 0x0f, 0x5e, 0x50,
	0x93, 0x17, 0xc2, 0xc4, 0x94, 0xb8, 0x04, 0x73, 0x82, 0xf5, 0x3d, 0xc6, 0xa9, 0x18, 0x70, 0xa6,
	0xce, 0x57, 0x27, 0xd3, 0x68, 0xeb, 0x5f, 0xf0, 0x7c, 0x88, 0xc1, 0x8b, 0x21, 0x06, 0x2f, 0x87,
	0x58, 0x7b, 0x35, 0xc4, 0xda, 0xeb, 0x21, 0xd6, 0xde, 0x0c, 0xb1, 0xf6, 0x76, 0x88, 0xc1, 0xc3,
	0x00, 0x83, 0x47, 0x01, 0xd6, 0x1e, 0x07, 0x18, 0x3c, 0x09, 0xb0, 0xf6, 0x34, 0xc0, 0xda, 0xb3,
	0x00, 0x6b, 0xcf, 0x03, 0x0c, 0x5e, 0x04, 0x18, 0xbc, 0x0c, 0xb0, 0xf6, 0x2a, 0xc0, 0xe0, 0x75,
	0x80, 0xb5, 0x37, 0x01, 0x06, 0x6f, 0x03, 0xac, 0x3d, 0x1c, 0x61, 0xed, 0xd1, 0x08, 0x83, 0x5f,
	0x46, 0x58, 0xfb, 0x75, 0x84, 0xc1, 0x6f, 0x23, 0xac, 0x3d, 0x1e, 0x61, 0xed, 0xc9, 0x08, 0x83,
	0xa7, 0x23, 0x0c, 0x9e, 0x8d, 0x30, 0x80, 0x25, 0x97, 0xf7, 0x2a, 0x62, 0x9f, 0x09, 0xf5, 0xfc,
	0x73, 0xc2, 0xe7, 0x5f, 0x85, 0x7a, 0xd6, 0xf8, 0xbc, 0xb6, 0x66, 0xa3, 0xe7, 0x45, 0x43, 0x3e,
	0xe3, 0x1a, 0xe0, 0xc7, 0x2b, 0x1f, 0xf8, 0x6e, 0xfc, 0x43, 0xbf, 0x7c, 0x3a, 0x5d, 0xd9, 0x6c,
	0x54, 0x2b, 0xd1, 0x74, 0x7b, 0x29, 0xf5, 0x2e, 0xbc, 0xf9, 0x5f, 0x00, 0x00, 0x00, 0xff, 0xff,
	0x47, 0x5a, 0xd4, 0x01, 0x88, 0x0a, 0x00, 0x00,
}
