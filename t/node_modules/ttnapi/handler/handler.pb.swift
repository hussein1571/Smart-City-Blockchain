// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: github.com/TheThingsNetwork/api/handler/handler.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

// Copyright Â© 2017 The Things Network
// Use of this source code is governed by the MIT license that can be found in the LICENSE file.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Handler_DeviceActivationResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var payload: Data {
    get {return _storage._payload}
    set {_uniqueStorage()._payload = newValue}
  }

  var message: Protocol_Message {
    get {return _storage._message ?? Protocol_Message()}
    set {_uniqueStorage()._message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  var hasMessage: Bool {return _storage._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  mutating func clearMessage() {_uniqueStorage()._message = nil}

  var downlinkOption: Broker_DownlinkOption {
    get {return _storage._downlinkOption ?? Broker_DownlinkOption()}
    set {_uniqueStorage()._downlinkOption = newValue}
  }
  /// Returns true if `downlinkOption` has been explicitly set.
  var hasDownlinkOption: Bool {return _storage._downlinkOption != nil}
  /// Clears the value of `downlinkOption`. Subsequent reads from it will return its default value.
  mutating func clearDownlinkOption() {_uniqueStorage()._downlinkOption = nil}

  var activationMetadata: Protocol_ActivationMetadata {
    get {return _storage._activationMetadata ?? Protocol_ActivationMetadata()}
    set {_uniqueStorage()._activationMetadata = newValue}
  }
  /// Returns true if `activationMetadata` has been explicitly set.
  var hasActivationMetadata: Bool {return _storage._activationMetadata != nil}
  /// Clears the value of `activationMetadata`. Subsequent reads from it will return its default value.
  mutating func clearActivationMetadata() {_uniqueStorage()._activationMetadata = nil}

  var trace: Trace_Trace {
    get {return _storage._trace ?? Trace_Trace()}
    set {_uniqueStorage()._trace = newValue}
  }
  /// Returns true if `trace` has been explicitly set.
  var hasTrace: Bool {return _storage._trace != nil}
  /// Clears the value of `trace`. Subsequent reads from it will return its default value.
  mutating func clearTrace() {_uniqueStorage()._trace = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// message StatusRequest is used to request the status of this Handler
struct Handler_StatusRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// message Status is the response to the StatusRequest
struct Handler_Status {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var system: Api_SystemStats {
    get {return _storage._system ?? Api_SystemStats()}
    set {_uniqueStorage()._system = newValue}
  }
  /// Returns true if `system` has been explicitly set.
  var hasSystem: Bool {return _storage._system != nil}
  /// Clears the value of `system`. Subsequent reads from it will return its default value.
  mutating func clearSystem() {_uniqueStorage()._system = nil}

  var component: Api_ComponentStats {
    get {return _storage._component ?? Api_ComponentStats()}
    set {_uniqueStorage()._component = newValue}
  }
  /// Returns true if `component` has been explicitly set.
  var hasComponent: Bool {return _storage._component != nil}
  /// Clears the value of `component`. Subsequent reads from it will return its default value.
  mutating func clearComponent() {_uniqueStorage()._component = nil}

  var uplink: Api_Rates {
    get {return _storage._uplink ?? Api_Rates()}
    set {_uniqueStorage()._uplink = newValue}
  }
  /// Returns true if `uplink` has been explicitly set.
  var hasUplink: Bool {return _storage._uplink != nil}
  /// Clears the value of `uplink`. Subsequent reads from it will return its default value.
  mutating func clearUplink() {_uniqueStorage()._uplink = nil}

  var downlink: Api_Rates {
    get {return _storage._downlink ?? Api_Rates()}
    set {_uniqueStorage()._downlink = newValue}
  }
  /// Returns true if `downlink` has been explicitly set.
  var hasDownlink: Bool {return _storage._downlink != nil}
  /// Clears the value of `downlink`. Subsequent reads from it will return its default value.
  mutating func clearDownlink() {_uniqueStorage()._downlink = nil}

  var activations: Api_Rates {
    get {return _storage._activations ?? Api_Rates()}
    set {_uniqueStorage()._activations = newValue}
  }
  /// Returns true if `activations` has been explicitly set.
  var hasActivations: Bool {return _storage._activations != nil}
  /// Clears the value of `activations`. Subsequent reads from it will return its default value.
  mutating func clearActivations() {_uniqueStorage()._activations = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Handler_ApplicationIdentifier {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var appID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The Application settings
struct Handler_Application {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var appID: String = String()

  /// The payload format indicates how payload is formatted.
  var payloadFormat: String = String()

  /// The decoder is a JavaScript function that decodes a byte array to an object.
  /// This function is used when the payload format is set to custom.
  var decoder: String = String()

  /// The converter is a JavaScript function that can be used to convert values
  /// in the object returned from the decoder. This can for example be useful to
  /// convert a voltage to a temperature. This function is used when the payload format is set to custom.
  var converter: String = String()

  /// The validator is a JavaScript function that checks the validity of the
  /// object returned by the decoder or converter. If validation fails, the
  /// message is dropped. This function is used when the payload format is set to custom.
  var validator: String = String()

  /// The encoder is a JavaScript function that encodes an object to a byte array.
  /// This function is used when the payload format is set to custom.
  var encoder: String = String()

  /// The "register on join" access key should only be set if devices need to be registered on join
  var registerOnJoinAccessKey: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Handler_DeviceIdentifier {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var appID: String = String()

  var devID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The Device settings
struct Handler_Device {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var appID: String {
    get {return _storage._appID}
    set {_uniqueStorage()._appID = newValue}
  }

  var devID: String {
    get {return _storage._devID}
    set {_uniqueStorage()._devID = newValue}
  }

  /// The device can be of different kinds
  var device: OneOf_Device? {
    get {return _storage._device}
    set {_uniqueStorage()._device = newValue}
  }

  var lorawanDevice: Lorawan_Device {
    get {
      if case .lorawanDevice(let v)? = _storage._device {return v}
      return Lorawan_Device()
    }
    set {_uniqueStorage()._device = .lorawanDevice(newValue)}
  }

  var latitude: Float {
    get {return _storage._latitude}
    set {_uniqueStorage()._latitude = newValue}
  }

  var longitude: Float {
    get {return _storage._longitude}
    set {_uniqueStorage()._longitude = newValue}
  }

  var altitude: Int32 {
    get {return _storage._altitude}
    set {_uniqueStorage()._altitude = newValue}
  }

  var attributes: Dictionary<String,String> {
    get {return _storage._attributes}
    set {_uniqueStorage()._attributes = newValue}
  }

  var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The device can be of different kinds
  enum OneOf_Device: Equatable {
    case lorawanDevice(Lorawan_Device)

  #if !swift(>=4.1)
    static func ==(lhs: Handler_Device.OneOf_Device, rhs: Handler_Device.OneOf_Device) -> Bool {
      switch (lhs, rhs) {
      case (.lorawanDevice(let l), .lorawanDevice(let r)): return l == r
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Handler_DeviceList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var devices: [Handler_Device] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// DryDownlinkMessage is a simulated message to test downlink processing
struct Handler_DryDownlinkMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The binary payload to use
  var payload: Data {
    get {return _storage._payload}
    set {_uniqueStorage()._payload = newValue}
  }

  /// JSON-encoded object with fields to encode
  var fields: String {
    get {return _storage._fields}
    set {_uniqueStorage()._fields = newValue}
  }

  /// The Application containing the payload functions that should be executed
  var app: Handler_Application {
    get {return _storage._app ?? Handler_Application()}
    set {_uniqueStorage()._app = newValue}
  }
  /// Returns true if `app` has been explicitly set.
  var hasApp: Bool {return _storage._app != nil}
  /// Clears the value of `app`. Subsequent reads from it will return its default value.
  mutating func clearApp() {_uniqueStorage()._app = nil}

  /// The port number that should be passed to the payload function
  var port: UInt32 {
    get {return _storage._port}
    set {_uniqueStorage()._port = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// DryUplinkMessage is a simulated message to test uplink processing
struct Handler_DryUplinkMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The binary payload to use
  var payload: Data {
    get {return _storage._payload}
    set {_uniqueStorage()._payload = newValue}
  }

  /// The Application containing the payload functions that should be executed
  var app: Handler_Application {
    get {return _storage._app ?? Handler_Application()}
    set {_uniqueStorage()._app = newValue}
  }
  /// Returns true if `app` has been explicitly set.
  var hasApp: Bool {return _storage._app != nil}
  /// Clears the value of `app`. Subsequent reads from it will return its default value.
  mutating func clearApp() {_uniqueStorage()._app = nil}

  /// The port number that should be passed to the payload function
  var port: UInt32 {
    get {return _storage._port}
    set {_uniqueStorage()._port = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// SimulatedUplinkMessage is a simulated uplink message
struct Handler_SimulatedUplinkMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var appID: String = String()

  var devID: String = String()

  /// The binary payload to use
  var payload: Data = SwiftProtobuf.Internal.emptyData

  /// The port number
  var port: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Handler_LogEntry {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The location where the log was created (what payload function)
  var function: String = String()

  /// A list of JSON-encoded fields that were logged
  var fields: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// DryUplinkResult is the result from an uplink simulation
struct Handler_DryUplinkResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The binary payload
  var payload: Data = SwiftProtobuf.Internal.emptyData

  /// The decoded fields
  var fields: String = String()

  /// Was validation of the message successful
  var valid: Bool = false

  /// Logs that have been generated while processing
  var logs: [Handler_LogEntry] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// DryDownlinkResult is the result from a downlink simulation
struct Handler_DryDownlinkResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The payload that was encoded
  var payload: Data = SwiftProtobuf.Internal.emptyData

  /// Logs that have been generated while processing
  var logs: [Handler_LogEntry] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "handler"

extension Handler_DeviceActivationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeviceActivationResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "payload"),
    2: .same(proto: "message"),
    11: .standard(proto: "downlink_option"),
    23: .standard(proto: "activation_metadata"),
    31: .same(proto: "trace"),
  ]

  fileprivate class _StorageClass {
    var _payload: Data = SwiftProtobuf.Internal.emptyData
    var _message: Protocol_Message? = nil
    var _downlinkOption: Broker_DownlinkOption? = nil
    var _activationMetadata: Protocol_ActivationMetadata? = nil
    var _trace: Trace_Trace? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _payload = source._payload
      _message = source._message
      _downlinkOption = source._downlinkOption
      _activationMetadata = source._activationMetadata
      _trace = source._trace
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularBytesField(value: &_storage._payload)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._message)
        case 11: try decoder.decodeSingularMessageField(value: &_storage._downlinkOption)
        case 23: try decoder.decodeSingularMessageField(value: &_storage._activationMetadata)
        case 31: try decoder.decodeSingularMessageField(value: &_storage._trace)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._payload.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._payload, fieldNumber: 1)
      }
      if let v = _storage._message {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._downlinkOption {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }
      if let v = _storage._activationMetadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      }
      if let v = _storage._trace {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Handler_DeviceActivationResponse, rhs: Handler_DeviceActivationResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._payload != rhs_storage._payload {return false}
        if _storage._message != rhs_storage._message {return false}
        if _storage._downlinkOption != rhs_storage._downlinkOption {return false}
        if _storage._activationMetadata != rhs_storage._activationMetadata {return false}
        if _storage._trace != rhs_storage._trace {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Handler_StatusRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StatusRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Handler_StatusRequest, rhs: Handler_StatusRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Handler_Status: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Status"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "system"),
    2: .same(proto: "component"),
    11: .same(proto: "uplink"),
    12: .same(proto: "downlink"),
    13: .same(proto: "activations"),
  ]

  fileprivate class _StorageClass {
    var _system: Api_SystemStats? = nil
    var _component: Api_ComponentStats? = nil
    var _uplink: Api_Rates? = nil
    var _downlink: Api_Rates? = nil
    var _activations: Api_Rates? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _system = source._system
      _component = source._component
      _uplink = source._uplink
      _downlink = source._downlink
      _activations = source._activations
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._system)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._component)
        case 11: try decoder.decodeSingularMessageField(value: &_storage._uplink)
        case 12: try decoder.decodeSingularMessageField(value: &_storage._downlink)
        case 13: try decoder.decodeSingularMessageField(value: &_storage._activations)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._system {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._component {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._uplink {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }
      if let v = _storage._downlink {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }
      if let v = _storage._activations {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Handler_Status, rhs: Handler_Status) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._system != rhs_storage._system {return false}
        if _storage._component != rhs_storage._component {return false}
        if _storage._uplink != rhs_storage._uplink {return false}
        if _storage._downlink != rhs_storage._downlink {return false}
        if _storage._activations != rhs_storage._activations {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Handler_ApplicationIdentifier: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ApplicationIdentifier"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "app_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.appID)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.appID.isEmpty {
      try visitor.visitSingularStringField(value: self.appID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Handler_ApplicationIdentifier, rhs: Handler_ApplicationIdentifier) -> Bool {
    if lhs.appID != rhs.appID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Handler_Application: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Application"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "app_id"),
    6: .standard(proto: "payload_format"),
    2: .same(proto: "decoder"),
    3: .same(proto: "converter"),
    4: .same(proto: "validator"),
    5: .same(proto: "encoder"),
    7: .standard(proto: "register_on_join_access_key"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.appID)
      case 2: try decoder.decodeSingularStringField(value: &self.decoder)
      case 3: try decoder.decodeSingularStringField(value: &self.converter)
      case 4: try decoder.decodeSingularStringField(value: &self.validator)
      case 5: try decoder.decodeSingularStringField(value: &self.encoder)
      case 6: try decoder.decodeSingularStringField(value: &self.payloadFormat)
      case 7: try decoder.decodeSingularStringField(value: &self.registerOnJoinAccessKey)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.appID.isEmpty {
      try visitor.visitSingularStringField(value: self.appID, fieldNumber: 1)
    }
    if !self.decoder.isEmpty {
      try visitor.visitSingularStringField(value: self.decoder, fieldNumber: 2)
    }
    if !self.converter.isEmpty {
      try visitor.visitSingularStringField(value: self.converter, fieldNumber: 3)
    }
    if !self.validator.isEmpty {
      try visitor.visitSingularStringField(value: self.validator, fieldNumber: 4)
    }
    if !self.encoder.isEmpty {
      try visitor.visitSingularStringField(value: self.encoder, fieldNumber: 5)
    }
    if !self.payloadFormat.isEmpty {
      try visitor.visitSingularStringField(value: self.payloadFormat, fieldNumber: 6)
    }
    if !self.registerOnJoinAccessKey.isEmpty {
      try visitor.visitSingularStringField(value: self.registerOnJoinAccessKey, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Handler_Application, rhs: Handler_Application) -> Bool {
    if lhs.appID != rhs.appID {return false}
    if lhs.payloadFormat != rhs.payloadFormat {return false}
    if lhs.decoder != rhs.decoder {return false}
    if lhs.converter != rhs.converter {return false}
    if lhs.validator != rhs.validator {return false}
    if lhs.encoder != rhs.encoder {return false}
    if lhs.registerOnJoinAccessKey != rhs.registerOnJoinAccessKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Handler_DeviceIdentifier: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeviceIdentifier"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "app_id"),
    2: .standard(proto: "dev_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.appID)
      case 2: try decoder.decodeSingularStringField(value: &self.devID)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.appID.isEmpty {
      try visitor.visitSingularStringField(value: self.appID, fieldNumber: 1)
    }
    if !self.devID.isEmpty {
      try visitor.visitSingularStringField(value: self.devID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Handler_DeviceIdentifier, rhs: Handler_DeviceIdentifier) -> Bool {
    if lhs.appID != rhs.appID {return false}
    if lhs.devID != rhs.devID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Handler_Device: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Device"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "app_id"),
    2: .standard(proto: "dev_id"),
    3: .standard(proto: "lorawan_device"),
    10: .same(proto: "latitude"),
    11: .same(proto: "longitude"),
    12: .same(proto: "altitude"),
    13: .same(proto: "attributes"),
    20: .same(proto: "description"),
  ]

  fileprivate class _StorageClass {
    var _appID: String = String()
    var _devID: String = String()
    var _device: Handler_Device.OneOf_Device?
    var _latitude: Float = 0
    var _longitude: Float = 0
    var _altitude: Int32 = 0
    var _attributes: Dictionary<String,String> = [:]
    var _description_p: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _appID = source._appID
      _devID = source._devID
      _device = source._device
      _latitude = source._latitude
      _longitude = source._longitude
      _altitude = source._altitude
      _attributes = source._attributes
      _description_p = source._description_p
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._appID)
        case 2: try decoder.decodeSingularStringField(value: &_storage._devID)
        case 3:
          var v: Lorawan_Device?
          if let current = _storage._device {
            try decoder.handleConflictingOneOf()
            if case .lorawanDevice(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._device = .lorawanDevice(v)}
        case 10: try decoder.decodeSingularFloatField(value: &_storage._latitude)
        case 11: try decoder.decodeSingularFloatField(value: &_storage._longitude)
        case 12: try decoder.decodeSingularInt32Field(value: &_storage._altitude)
        case 13: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._attributes)
        case 20: try decoder.decodeSingularStringField(value: &_storage._description_p)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._appID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._appID, fieldNumber: 1)
      }
      if !_storage._devID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._devID, fieldNumber: 2)
      }
      if case .lorawanDevice(let v)? = _storage._device {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if _storage._latitude != 0 {
        try visitor.visitSingularFloatField(value: _storage._latitude, fieldNumber: 10)
      }
      if _storage._longitude != 0 {
        try visitor.visitSingularFloatField(value: _storage._longitude, fieldNumber: 11)
      }
      if _storage._altitude != 0 {
        try visitor.visitSingularInt32Field(value: _storage._altitude, fieldNumber: 12)
      }
      if !_storage._attributes.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._attributes, fieldNumber: 13)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 20)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Handler_Device, rhs: Handler_Device) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._appID != rhs_storage._appID {return false}
        if _storage._devID != rhs_storage._devID {return false}
        if _storage._device != rhs_storage._device {return false}
        if _storage._latitude != rhs_storage._latitude {return false}
        if _storage._longitude != rhs_storage._longitude {return false}
        if _storage._altitude != rhs_storage._altitude {return false}
        if _storage._attributes != rhs_storage._attributes {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Handler_DeviceList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeviceList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "devices"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.devices)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.devices.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.devices, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Handler_DeviceList, rhs: Handler_DeviceList) -> Bool {
    if lhs.devices != rhs.devices {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Handler_DryDownlinkMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DryDownlinkMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "payload"),
    2: .same(proto: "fields"),
    3: .same(proto: "app"),
    4: .same(proto: "port"),
  ]

  fileprivate class _StorageClass {
    var _payload: Data = SwiftProtobuf.Internal.emptyData
    var _fields: String = String()
    var _app: Handler_Application? = nil
    var _port: UInt32 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _payload = source._payload
      _fields = source._fields
      _app = source._app
      _port = source._port
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularBytesField(value: &_storage._payload)
        case 2: try decoder.decodeSingularStringField(value: &_storage._fields)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._app)
        case 4: try decoder.decodeSingularUInt32Field(value: &_storage._port)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._payload.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._payload, fieldNumber: 1)
      }
      if !_storage._fields.isEmpty {
        try visitor.visitSingularStringField(value: _storage._fields, fieldNumber: 2)
      }
      if let v = _storage._app {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if _storage._port != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._port, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Handler_DryDownlinkMessage, rhs: Handler_DryDownlinkMessage) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._payload != rhs_storage._payload {return false}
        if _storage._fields != rhs_storage._fields {return false}
        if _storage._app != rhs_storage._app {return false}
        if _storage._port != rhs_storage._port {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Handler_DryUplinkMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DryUplinkMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "payload"),
    2: .same(proto: "app"),
    3: .same(proto: "port"),
  ]

  fileprivate class _StorageClass {
    var _payload: Data = SwiftProtobuf.Internal.emptyData
    var _app: Handler_Application? = nil
    var _port: UInt32 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _payload = source._payload
      _app = source._app
      _port = source._port
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularBytesField(value: &_storage._payload)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._app)
        case 3: try decoder.decodeSingularUInt32Field(value: &_storage._port)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._payload.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._payload, fieldNumber: 1)
      }
      if let v = _storage._app {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if _storage._port != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._port, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Handler_DryUplinkMessage, rhs: Handler_DryUplinkMessage) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._payload != rhs_storage._payload {return false}
        if _storage._app != rhs_storage._app {return false}
        if _storage._port != rhs_storage._port {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Handler_SimulatedUplinkMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SimulatedUplinkMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "app_id"),
    2: .standard(proto: "dev_id"),
    3: .same(proto: "payload"),
    4: .same(proto: "port"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.appID)
      case 2: try decoder.decodeSingularStringField(value: &self.devID)
      case 3: try decoder.decodeSingularBytesField(value: &self.payload)
      case 4: try decoder.decodeSingularUInt32Field(value: &self.port)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.appID.isEmpty {
      try visitor.visitSingularStringField(value: self.appID, fieldNumber: 1)
    }
    if !self.devID.isEmpty {
      try visitor.visitSingularStringField(value: self.devID, fieldNumber: 2)
    }
    if !self.payload.isEmpty {
      try visitor.visitSingularBytesField(value: self.payload, fieldNumber: 3)
    }
    if self.port != 0 {
      try visitor.visitSingularUInt32Field(value: self.port, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Handler_SimulatedUplinkMessage, rhs: Handler_SimulatedUplinkMessage) -> Bool {
    if lhs.appID != rhs.appID {return false}
    if lhs.devID != rhs.devID {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs.port != rhs.port {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Handler_LogEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LogEntry"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "function"),
    2: .same(proto: "fields"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.function)
      case 2: try decoder.decodeRepeatedStringField(value: &self.fields)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.function.isEmpty {
      try visitor.visitSingularStringField(value: self.function, fieldNumber: 1)
    }
    if !self.fields.isEmpty {
      try visitor.visitRepeatedStringField(value: self.fields, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Handler_LogEntry, rhs: Handler_LogEntry) -> Bool {
    if lhs.function != rhs.function {return false}
    if lhs.fields != rhs.fields {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Handler_DryUplinkResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DryUplinkResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "payload"),
    2: .same(proto: "fields"),
    3: .same(proto: "valid"),
    4: .same(proto: "logs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.payload)
      case 2: try decoder.decodeSingularStringField(value: &self.fields)
      case 3: try decoder.decodeSingularBoolField(value: &self.valid)
      case 4: try decoder.decodeRepeatedMessageField(value: &self.logs)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.payload.isEmpty {
      try visitor.visitSingularBytesField(value: self.payload, fieldNumber: 1)
    }
    if !self.fields.isEmpty {
      try visitor.visitSingularStringField(value: self.fields, fieldNumber: 2)
    }
    if self.valid != false {
      try visitor.visitSingularBoolField(value: self.valid, fieldNumber: 3)
    }
    if !self.logs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.logs, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Handler_DryUplinkResult, rhs: Handler_DryUplinkResult) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.fields != rhs.fields {return false}
    if lhs.valid != rhs.valid {return false}
    if lhs.logs != rhs.logs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Handler_DryDownlinkResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DryDownlinkResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "payload"),
    2: .same(proto: "logs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.payload)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.logs)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.payload.isEmpty {
      try visitor.visitSingularBytesField(value: self.payload, fieldNumber: 1)
    }
    if !self.logs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.logs, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Handler_DryDownlinkResult, rhs: Handler_DryDownlinkResult) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.logs != rhs.logs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
