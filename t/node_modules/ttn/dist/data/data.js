"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DataClient = undefined;

var _stringify = require("babel-runtime/core-js/json/stringify");

var _stringify2 = _interopRequireDefault(_stringify);

var _toConsumableArray2 = require("babel-runtime/helpers/toConsumableArray");

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _slicedToArray2 = require("babel-runtime/helpers/slicedToArray");

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require("babel-runtime/helpers/createClass");

var _createClass3 = _interopRequireDefault(_createClass2);

var _sourceMapSupport2 = require("source-map-support");

var _events = require("events");

var _events2 = _interopRequireDefault(_events);

var _mqtt = require("mqtt");

var _mqtt2 = _interopRequireDefault(_mqtt);

var _debug = require("../utils/debug");

var _debug2 = _interopRequireDefault(_debug);

var _topic = require("./topic");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(0, _sourceMapSupport2.install)(); // Copyright Â© 2017 The Things Network
// Use of this source code is governed by the MIT license that can be found in the LICENSE file.

/**
 * DataClient is a client for The Things Network data API.
 */
var DataClient = exports.DataClient = function () {

  /**
   * Creates a new DataClient and opens the MQTT connection.
   */


  /** @private */
  function DataClient(appID, appAccessKey, mqttAddress) {
    (0, _classCallCheck3.default)(this, DataClient);

    this.appID = appID;
    this.emitter = new _events2.default();

    var _mqttAddress$split = mqttAddress.split(":"),
        _mqttAddress$split2 = (0, _slicedToArray3.default)(_mqttAddress$split, 2),
        host = _mqttAddress$split2[0],
        _mqttAddress$split2$ = _mqttAddress$split2[1],
        port = _mqttAddress$split2$ === undefined ? "1883" : _mqttAddress$split2$;

    (0, _debug2.default)("connecting to mqtt host `%s` on port %d, using username `%s`", host, parseInt(port), appID);

    this.mqtt = _mqtt2.default.connect({
      host: host,
      port: parseInt(port),
      username: appID,
      password: appAccessKey
    });

    this.mqtt.on("error", this.onError.bind(this));
    this.mqtt.on("connect", this.onConnect.bind(this));
    this.mqtt.on("message", this.onMessage.bind(this));
    this.mqtt.on("reconnect", this.onReconnect.bind(this));
    this.mqtt.on("offline", this.onDisconnect.bind(this));
    this.mqtt.on("close", this.onClose.bind(this));
  }

  /**
   * Close the mqtt connection
   *
   * @param force - passing it to true will close the client right away, without waiting for the in-flight messages to be acked
   * @param callback - will be called when the client is closed
   */


  /** @private */

  /** @private */


  (0, _createClass3.default)(DataClient, [{
    key: "close",
    value: function close() {
      var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var callback = arguments[1];

      (0, _debug2.default)("closing mqtt client");
      return this.mqtt.end(force, callback);
    }

    /**
     * Same as close (for backwards compatibility).
     */

  }, {
    key: "end",
    value: function end(force, callback) {
      return this.close(force, callback);
    }

    /**
     * Starts listening to events.
     *
     * Possible events (application messages):
     *
     * - `uplink` (or `message`): Messages sent by the devices to the appliction.
     * - `activation`: An alias for the `activations` (see `event`)
     * - `event` (or `device`): Events that happen to devices. You can filter on
     *   the events by adding more parameters. For instance:
     *   - `downlink/scheduled`
     *   - `downlink/sent`
     *   - `activations`
     *   - `create`
     *   - `update`
     *   - `delete`
     *   - `down/acks`
     *   - `up/errors`
     *   - `down/errors`
     *   - `activations/errors`
     *
     * See [The MQTT API Reference](https://www.thethingsnetwork.org/docs/applications/mqtt/api.html)
     * for more information about these events and what their payloads look like.
     *
     * MQTT connection events:
     *
     * - `error`: An error occured / the initial connection failed.
     * - `connect`: A connection to the MQTT broker was established.
     * - `disconnect`: The connection to the MQTT broker was lost.
     * - `reconnect`: A reconnect to the MQTT broker is attempted.
     * - `close`: A connection (attempt) failed.
     *
     *
     * @param event - The name of the event to listen to.
     * @param [devID] - An optional devID. If not passed will subscribe to the event for all devices.
     * @param [name|field] - The name of the field to listen for on uplink or the event for device events.
     * @param callback - The callback to call when the event occurs.
     *
     * @example
     * // listens to all uplinks from all devices
     * client.on("uplink", function (devID, message) {})
     *
     * @example
     * // listens to all uplinks from the device with id `foo`
     * client.on("uplink", "foo", function (devID, message) {})
     *
     * @example
     * // listens to all device events for all devices
     * client.on("event", function (devID, message) {})
     *
     * @example
     * // listens to all device events for device with id `foo`
     * client.on("event", "foo", function (devID, message) {})
     *
     * @example
     * // listens to the `downlink/scheduled` events for device with id `foo`
     * client.on("event", "foo", "downlink/scheduled", function (devID, message) {})
     *
     * @example
     * // listens to the `downlink/scheduled` events for all devices
     * client.on("event", "+", "downlink/scheduled", function (devID, message) {})
     */

  }, {
    key: "on",
    value: function on(event) {
      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      return this.toggle.apply(this, [true, event].concat(args));
    }

    /**
     * Stop listening to events.
     * The argument structure is the same as for `on()`.
     */

  }, {
    key: "off",
    value: function off(event) {
      for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }

      return this.toggle.apply(this, [false, event].concat(args));
    }

    /**
     * @private
     * Toggles the subscription matching to the received arguments
     *
     */

  }, {
    key: "toggle",
    value: function toggle(on, event) {
      for (var _len3 = arguments.length, args = Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
        args[_key3 - 2] = arguments[_key3];
      }

      if (args.length < 1) {
        throw new Error("Need at least one argument to on");
      }

      var rest = args.slice(0);

      var cb = rest.pop();

      var t = null;

      switch (event) {
        case "uplink":
        case "message":
          t = _topic.uplinkTopic.apply(undefined, (0, _toConsumableArray3.default)(rest));
          break;
        case "device":
        case "event":
        case "events":
          t = _topic.eventTopic.apply(undefined, (0, _toConsumableArray3.default)(rest));
          break;
        case "activation":
        case "activations":
          var _rest = (0, _slicedToArray3.default)(rest, 1),
              _rest$ = _rest[0],
              _devID = _rest$ === undefined ? _topic.wildcard : _rest$;

          t = (0, _topic.eventTopic)(_devID, "activations");
          break;
        case "error":
        case "connect":
        case "reconnect":
        case "disconnect":
        case "close":
          this.emitter.on(event, cb);
          return;
      }

      if (t === null) {
        throw new Error("Could not build topic");
      }

      if (on) {
        this.subscribe(t, cb);
      } else {
        this.unsubscribe(t, cb);
      }
    }

    /**
     * Send a downlink message to the device with the specified device ID.
     *
     * @param devID - The device ID of the device to send the downlink to.
     * @param payload - The raw payload as a Buffer, an Array of numbers, a hex string  or an object of payload fields.
     * @param port - The port to send the message on.
     * @param confirmed - Set to true for confirmed downlink.
     * @param schedule - Set to the scheduling you want to use (first, last or replace).
     */

  }, {
    key: "send",
    value: function send(devID, payload) {
      var port = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
      var confirmed = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      var schedule = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : "replace";

      var t = (0, _topic.downlinkTopic)(this.appID, devID);
      var message = {
        port: port,
        confirmed: confirmed,
        schedule: schedule
      };

      if (Array.isArray(payload)) {
        message.payload_raw = new Buffer(payload).toString("base64");
      } else if (payload instanceof Buffer) {
        message.payload_raw = payload.toString("base64");
      } else if (typeof payload === "string") {
        message.payload_raw = new Buffer(payload, "hex").toString("base64");
      } else {
        message.payload_fields = payload;
      }

      (0, _debug2.default)("publishing message to %s: %O", t, message);

      this.mqtt.publish(t, (0, _stringify2.default)(message));
    }

    /**
     * @private
     * `onError` is called whenever there's an error in the MQTT client.
     */

  }, {
    key: "onError",
    value: function onError(err) {
      (0, _debug2.default)("mqtt client received error: %s", err);
      this.emitter.emit("error", err);
    }

    /**
     * @private
     * `onConnect` is called whenever the MQTT client (re-)connects.
     */

  }, {
    key: "onConnect",
    value: function onConnect(ack) {
      (0, _debug2.default)("mqtt client connected");
      this.emitter.emit("connect", ack);
    }

    /**
     * @private
     * `onReconnect` is called whenever the MQTT client starts reconnecting.
     */

  }, {
    key: "onReconnect",
    value: function onReconnect() {
      (0, _debug2.default)("mqtt client reconnecting");
      this.emitter.emit("reconnect", undefined);
    }

    /**
     * @private
     * `onDisconnect` is called whenever the MQTT client lost its connection,
     * after the keepalive has timed out.
     */

  }, {
    key: "onDisconnect",
    value: function onDisconnect() {
      (0, _debug2.default)("mqtt client disconnected");
      this.emitter.emit("disconnect", undefined);
    }

    /**
     * @private
     * `onClose` is called after the MQTT disconnects.
     */

  }, {
    key: "onClose",
    value: function onClose() {
      (0, _debug2.default)("mqtt client disconnected");
      this.emitter.emit("close", undefined);
    }

    /**
     * @private
     * `onMessage` is called when a new message is received from any subscription.
     */

  }, {
    key: "onMessage",
    value: function onMessage(topic, message) {
      var _this = this;

      var payload = JSON.parse(message.toString());

      if (payload && typeof payload.payload_raw === "string") {
        payload.payload_raw = new Buffer(payload.payload_raw, "base64");
      }

      (0, _debug2.default)("received message on topic `%s`: %O", topic, payload);

      var dev = (0, _topic.devID)(topic);
      (0, _topic.validWildcards)(topic).forEach(function (topic) {
        return _this.emitter.emit(topic, dev, payload);
      });
    }

    /**
     * @private
     * `subscribe` subscribes the mqtt client to the specified topic and hooks up
     * the callback in the event emitter.
     */

  }, {
    key: "subscribe",
    value: function subscribe(topic, cb) {
      (0, _debug2.default)("subscribing to messages on topic `%s`", topic);
      this.mqtt.subscribe(topic);
      this.emitter.on(topic, cb);
    }

    /**
     * @private
     * `unsubscribe` unsubscribes the mqtt client from the specified topic and
     * removes the callback from the event emitter.
     */

  }, {
    key: "unsubscribe",
    value: function unsubscribe(topic, cb) {
      (0, _debug2.default)("unsubscribing from messages on topic `%s`", topic);
      this.mqtt.unsubscribe(topic);
      this.emitter.removeListener(topic, cb);
    }
  }]);
  return DataClient;
}();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9kYXRhL2RhdGEuanMiXSwibmFtZXMiOlsiRGF0YUNsaWVudCIsImFwcElEIiwiYXBwQWNjZXNzS2V5IiwibXF0dEFkZHJlc3MiLCJlbWl0dGVyIiwiRXZlbnRFbWl0dGVyIiwic3BsaXQiLCJob3N0IiwicG9ydCIsInBhcnNlSW50IiwibXF0dCIsImNvbm5lY3QiLCJ1c2VybmFtZSIsInBhc3N3b3JkIiwib24iLCJvbkVycm9yIiwiYmluZCIsIm9uQ29ubmVjdCIsIm9uTWVzc2FnZSIsIm9uUmVjb25uZWN0Iiwib25EaXNjb25uZWN0Iiwib25DbG9zZSIsImZvcmNlIiwiY2FsbGJhY2siLCJlbmQiLCJjbG9zZSIsImV2ZW50IiwiYXJncyIsInRvZ2dsZSIsImxlbmd0aCIsIkVycm9yIiwicmVzdCIsImNiIiwicG9wIiwidCIsInVwbGlua1RvcGljIiwiZXZlbnRUb3BpYyIsImRldklEIiwid2lsZGNhcmQiLCJzdWJzY3JpYmUiLCJ1bnN1YnNjcmliZSIsInBheWxvYWQiLCJjb25maXJtZWQiLCJzY2hlZHVsZSIsIm1lc3NhZ2UiLCJBcnJheSIsImlzQXJyYXkiLCJwYXlsb2FkX3JhdyIsIkJ1ZmZlciIsInRvU3RyaW5nIiwicGF5bG9hZF9maWVsZHMiLCJwdWJsaXNoIiwiZXJyIiwiZW1pdCIsImFjayIsInVuZGVmaW5lZCIsInRvcGljIiwiSlNPTiIsInBhcnNlIiwiZGV2IiwiZm9yRWFjaCIsInJlbW92ZUxpc3RlbmVyIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUtBOzs7O0FBQ0E7Ozs7QUFFQTs7OztBQUVBOzs7O21DQVZBO0FBQ0E7O0FBOEJBOzs7SUFHYUEsVSxXQUFBQSxVOztBQVVYOzs7OztBQU5BO0FBU0Esc0JBQWFDLEtBQWIsRUFBNkJDLFlBQTdCLEVBQW9EQyxXQUFwRCxFQUFpRjtBQUFBOztBQUMvRSxTQUFLRixLQUFMLEdBQWFBLEtBQWI7QUFDQSxTQUFLRyxPQUFMLEdBQWUsSUFB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LEssRUFBZ0JaLE8sRUFBc0I7QUFBQTs7QUFDL0MsVUFBTUgsVUFBVWdCLEtBQUtDLEtBQUwsQ0FBV2QsUUFBUUssUUFBUixFQUFYLENBQWhCOztBQUVBLFVBQUlSLFdBQVcsT0FBT0EsUUFBUU0sV0FBZixLQUErQixRQUE5QyxFQUF3RDtBQUN0RE4sZ0JBQVFNLFdBQVIsR0FBc0IsSUFBSUMsTUFBSixDQUFXUCxRQUFRTSxXQUFuQixFQUFnQyxRQUFoQyxDQUF0QjtBQUNEOztBQUVELDJCQUFNLG9DQUFOLEVBQTRDUyxLQUE1QyxFQUFtRGYsT0FBbkQ7O0FBRUEsVUFBTWtCLE1BQU0sa0JBQU1ILEtBQU4sQ0FBWjtBQUNBLGlDQUFlQSxLQUFmLEVBQXNCSSxPQUF0QixDQUE4QjtBQUFBLGVBQVMsTUFBS3hELE9BQUwsQ0FBYWlELElBQWIsQ0FBa0JHLEtBQWxCLEVBQXlCRyxHQUF6QixFQUE4QmxCLE9BQTlCLENBQVQ7QUFBQSxPQUE5QjtBQUNEOztBQUVEOzs7Ozs7Ozs4QkFLV2UsSyxFQUFnQnhCLEUsRUFBc0I7QUFDL0MsMkJBQU0sdUNBQU4sRUFBK0N3QixLQUEvQztBQUNBLFdBQUs5QyxJQUFMLENBQVU2QixTQUFWLENBQW9CaUIsS0FBcEI7QUFDQSxXQUFLcEQsT0FBTCxDQUFhVSxFQUFiLENBQWdCMEMsS0FBaEIsRUFBdUJ4QixFQUF2QjtBQUNEOztBQUVEOzs7Ozs7OztnQ0FLYXdCLEssRUFBZ0J4QixFLEVBQXNCO0FBQ2pELDJCQUFNLDJDQUFOLEVBQW1Ed0IsS0FBbkQ7QUFDQSxXQUFLOUMsSUFBTCxDQUFVOEIsV0FBVixDQUFzQmdCLEtBQXRCO0FBQ0EsV0FBS3BELE9BQUwsQ0FBYXlELGNBQWIsQ0FBNEJMLEtBQTVCLEVBQW1DeEIsRUFBbkM7QUFDRCIsImZpbGUiOiJkYXRhLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IMKpIDIwMTcgVGhlIFRoaW5ncyBOZXR3b3JrXG4vLyBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSB0aGUgTUlUIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZS5cblxuLy8gQGZsb3dcblxuaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tIFwiZXZlbnRzXCJcbmltcG9ydCBtcXR0IGZyb20gXCJtcXR0XCJcblxuaW1wb3J0IGRlYnVnIGZyb20gXCIuLi91dGlscy9kZWJ1Z1wiXG5cbmltcG9ydCB7IGRldklELCB3aWxkY2FyZCwgdXBsaW5rVG9waWMsIGV2ZW50VG9waWMsIGRvd25saW5rVG9waWMsIHZhbGlkV2lsZGNhcmRzIH0gZnJvbSBcIi4vdG9waWNcIlxuXG50eXBlIERldmljZUlEID0gc3RyaW5nXG50eXBlIENvbm5hY2sgPSB7XG4gIHNlc3Npb25QcmVzZW50IDogYm9vbGVhbixcbn1cblxudHlwZSBQYXlsb2FkQXJyYXkgPSBBcnJheTxudW1iZXI+XG50eXBlIFBheWxvYWRSYXcgPSBCdWZmZXJcbnR5cGUgUGF5bG9hZEZpZWxkcyA9IHsgW3N0cmluZ106IGFueSB9XG50eXBlIFNjaGVkdWxlID0gXCJyZXBsYWNlXCIgfCBcImZpcnN0XCIgfCBcImxhc3RcIlxuXG50eXBlIERvd25saW5rTWVzc2FnZSA9IHtcbiAgcG9ydCA6IG51bWJlcixcbiAgcGF5bG9hZF9yYXc/IDogc3RyaW5nLFxuICBwYXlsb2FkX2ZpZWxkcz8gOiBQYXlsb2FkRmllbGRzLFxuICBjb25maXJtZWQ/IDogYm9vbGVhbixcbiAgc2NoZWR1bGU/IDogU2NoZWR1bGUsXG59XG5cblxuLyoqXG4gKiBEYXRhQ2xpZW50IGlzIGEgY2xpZW50IGZvciBUaGUgVGhpbmdzIE5ldHdvcmsgZGF0YSBBUEkuXG4gKi9cbmV4cG9ydCBjbGFzcyBEYXRhQ2xpZW50IHtcbiAgLyoqIEBwcml2YXRlICovXG4gIGFwcElEIDogc3RyaW5nXG5cbiAgLyoqIEBwcml2YXRlICovXG4gIGVtaXR0ZXIgOiBFdmVudEVtaXR0ZXJcblxuICAvKiogQHByaXZhdGUgKi9cbiAgbXF0dCA6IGFueVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IERhdGFDbGllbnQgYW5kIG9wZW5zIHRoZSBNUVRUIGNvbm5lY3Rpb24uXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoYXBwSUQgOiBzdHJpbmcsIGFwcEFjY2Vzc0tleSA6IHN0cmluZywgbXF0dEFkZHJlc3MgOiBzdHJpbmcpIDogdm9pZCB7XG4gICAgdGhpcy5hcHBJRCA9IGFwcElEXG4gICAgdGhpcy5lbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcigpXG5cbiAgICBjb25zdCBbIGhvc3QsIHBvcnQgPSBcIjE4ODNcIiBdID0gbXF0dEFkZHJlc3Muc3BsaXQoXCI6XCIpXG5cbiAgICBkZWJ1ZyhcImNvbm5lY3RpbmcgdG8gbXF0dCBob3N0IGAlc2Agb24gcG9ydCAlZCwgdXNpbmcgdXNlcm5hbWUgYCVzYFwiLCBob3N0LCBwYXJzZUludChwb3J0KSwgYXBwSUQpXG5cbiAgICB0aGlzLm1xdHQgPSBtcXR0LmNvbm5lY3Qoe1xuICAgICAgaG9zdCxcbiAgICAgIHBvcnQ6IHBhcnNlSW50KHBvcnQpLFxuICAgICAgdXNlcm5hbWU6IGFwcElELFxuICAgICAgcGFzc3dvcmQ6IGFwcEFjY2Vzc0tleSxcbiAgICB9KVxuXG4gICAgdGhpcy5tcXR0Lm9uKFwiZXJyb3JcIiwgdGhpcy5vbkVycm9yLmJpbmQodGhpcykpXG4gICAgdGhpcy5tcXR0Lm9uKFwiY29ubmVjdFwiLCB0aGlzLm9uQ29ubmVjdC5iaW5kKHRoaXMpKVxuICAgIHRoaXMubXF0dC5vbihcIm1lc3NhZ2VcIiwgdGhpcy5vbk1lc3NhZ2UuYmluZCh0aGlzKSlcbiAgICB0aGlzLm1xdHQub24oXCJyZWNvbm5lY3RcIiwgdGhpcy5vblJlY29ubmVjdC5iaW5kKHRoaXMpKVxuICAgIHRoaXMubXF0dC5vbihcIm9mZmxpbmVcIiwgdGhpcy5vbkRpc2Nvbm5lY3QuYmluZCh0aGlzKSlcbiAgICB0aGlzLm1xdHQub24oXCJjbG9zZVwiLCB0aGlzLm9uQ2xvc2UuYmluZCh0aGlzKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9zZSB0aGUgbXF0dCBjb25uZWN0aW9uXG4gICAqXG4gICAqIEBwYXJhbSBmb3JjZSAtIHBhc3NpbmcgaXQgdG8gdHJ1ZSB3aWxsIGNsb3NlIHRoZSBjbGllbnQgcmlnaHQgYXdheSwgd2l0aG91dCB3YWl0aW5nIGZvciB0aGUgaW4tZmxpZ2h0IG1lc3NhZ2VzIHRvIGJlIGFja2VkXG4gICAqIEBwYXJhbSBjYWxsYmFjayAtIHdpbGwgYmUgY2FsbGVkIHdoZW4gdGhlIGNsaWVudCBpcyBjbG9zZWRcbiAgICovXG4gIGNsb3NlIChmb3JjZSA6ID9ib29sZWFuID0gZmFsc2UsIGNhbGxiYWNrIDogP0Z1bmN0aW9uKSB7XG4gICAgZGVidWcoXCJjbG9zaW5nIG1xdHQgY2xpZW50XCIpXG4gICAgcmV0dXJuIHRoaXMubXF0dC5lbmQoZm9yY2UsIGNhbGxiYWNrKVxuICB9XG5cbiAgLyoqXG4gICAqIFNhbWUgYXMgY2xvc2UgKGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSkuXG4gICAqL1xuICBlbmQgKGZvcmNlIDogP2Jvb2xlYW4sIGNhbGxiYWNrIDogP0Z1bmN0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvc2UoZm9yY2UsIGNhbGxiYWNrKVxuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0cyBsaXN0ZW5pbmcgdG8gZXZlbnRzLlxuICAgKlxuICAgKiBQb3NzaWJsZSBldmVudHMgKGFwcGxpY2F0aW9uIG1lc3NhZ2VzKTpcbiAgICpcbiAgICogLSBgdXBsaW5rYCAob3IgYG1lc3NhZ2VgKTogTWVzc2FnZXMgc2VudCBieSB0aGUgZGV2aWNlcyB0byB0aGUgYXBwbGljdGlvbi5cbiAgICogLSBgYWN0aXZhdGlvbmA6IEFuIGFsaWFzIGZvciB0aGUgYGFjdGl2YXRpb25zYCAoc2VlIGBldmVudGApXG4gICAqIC0gYGV2ZW50YCAob3IgYGRldmljZWApOiBFdmVudHMgdGhhdCBoYXBwZW4gdG8gZGV2aWNlcy4gWW91IGNhbiBmaWx0ZXIgb25cbiAgICogICB0aGUgZXZlbnRzIGJ5IGFkZGluZyBtb3JlIHBhcmFtZXRlcnMuIEZvciBpbnN0YW5jZTpcbiAgICogICAtIGBkb3dubGluay9zY2hlZHVsZWRgXG4gICAqICAgLSBgZG93bmxpbmsvc2VudGBcbiAgICogICAtIGBhY3RpdmF0aW9uc2BcbiAgICogICAtIGBjcmVhdGVgXG4gICAqICAgLSBgdXBkYXRlYFxuICAgKiAgIC0gYGRlbGV0ZWBcbiAgICogICAtIGBkb3duL2Fja3NgXG4gICAqICAgLSBgdXAvZXJyb3JzYFxuICAgKiAgIC0gYGRvd24vZXJyb3JzYFxuICAgKiAgIC0gYGFjdGl2YXRpb25zL2Vycm9yc2BcbiAgICpcbiAgICogU2VlIFtUaGUgTVFUVCBBUEkgUmVmZXJlbmNlXShodHRwczovL3d3dy50aGV0aGluZ3NuZXR3b3JrLm9yZy9kb2NzL2FwcGxpY2F0aW9ucy9tcXR0L2FwaS5odG1sKVxuICAgKiBmb3IgbW9yZSBpbmZvcm1hdGlvbiBhYm91dCB0aGVzZSBldmVudHMgYW5kIHdoYXQgdGhlaXIgcGF5bG9hZHMgbG9vayBsaWtlLlxuICAgKlxuICAgKiBNUVRUIGNvbm5lY3Rpb24gZXZlbnRzOlxuICAgKlxuICAgKiAtIGBlcnJvcmA6IEFuIGVycm9yIG9jY3VyZWQgLyB0aGUgaW5pdGlhbCBjb25uZWN0aW9uIGZhaWxlZC5cbiAgICogLSBgY29ubmVjdGA6IEEgY29ubmVjdGlvbiB0byB0aGUgTVFUVCBicm9rZXIgd2FzIGVzdGFibGlzaGVkLlxuICAgKiAtIGBkaXNjb25uZWN0YDogVGhlIGNvbm5lY3Rpb24gdG8gdGhlIE1RVFQgYnJva2VyIHdhcyBsb3N0LlxuICAgKiAtIGByZWNvbm5lY3RgOiBBIHJlY29ubmVjdCB0byB0aGUgTVFUVCBicm9rZXIgaXMgYXR0ZW1wdGVkLlxuICAgKiAtIGBjbG9zZWA6IEEgY29ubmVjdGlvbiAoYXR0ZW1wdCkgZmFpbGVkLlxuICAgKlxuICAgKlxuICAgKiBAcGFyYW0gZXZlbnQgLSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gbGlzdGVuIHRvLlxuICAgKiBAcGFyYW0gW2RldklEXSAtIEFuIG9wdGlvbmFsIGRldklELiBJZiBub3QgcGFzc2VkIHdpbGwgc3Vic2NyaWJlIHRvIHRoZSBldmVudCBmb3IgYWxsIGRldmljZXMuXG4gICAqIEBwYXJhbSBbbmFtZXxmaWVsZF0gLSBUaGUgbmFtZSBvZiB0aGUgZmllbGQgdG8gbGlzdGVuIGZvciBvbiB1cGxpbmsgb3IgdGhlIGV2ZW50IGZvciBkZXZpY2UgZXZlbnRzLlxuICAgKiBAcGFyYW0gY2FsbGJhY2sgLSBUaGUgY2FsbGJhY2sgdG8gY2FsbCB3aGVuIHRoZSBldmVudCBvY2N1cnMuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIC8vIGxpc3RlbnMgdG8gYWxsIHVwbGlua3MgZnJvbSBhbGwgZGV2aWNlc1xuICAgKiBjbGllbnQub24oXCJ1cGxpbmtcIiwgZnVuY3Rpb24gKGRldklELCBtZXNzYWdlKSB7fSlcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogLy8gbGlzdGVucyB0byBhbGwgdXBsaW5rcyBmcm9tIHRoZSBkZXZpY2Ugd2l0aCBpZCBgZm9vYFxuICAgKiBjbGllbnQub24oXCJ1cGxpbmtcIiwgXCJmb29cIiwgZnVuY3Rpb24gKGRldklELCBtZXNzYWdlKSB7fSlcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogLy8gbGlzdGVucyB0byBhbGwgZGV2aWNlIGV2ZW50cyBmb3IgYWxsIGRldmljZXNcbiAgICogY2xpZW50Lm9uKFwiZXZlbnRcIiwgZnVuY3Rpb24gKGRldklELCBtZXNzYWdlKSB7fSlcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogLy8gbGlzdGVucyB0byBhbGwgZGV2aWNlIGV2ZW50cyBmb3IgZGV2aWNlIHdpdGggaWQgYGZvb2BcbiAgICogY2xpZW50Lm9uKFwiZXZlbnRcIiwgXCJmb29cIiwgZnVuY3Rpb24gKGRldklELCBtZXNzYWdlKSB7fSlcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogLy8gbGlzdGVucyB0byB0aGUgYGRvd25saW5rL3NjaGVkdWxlZGAgZXZlbnRzIGZvciBkZXZpY2Ugd2l0aCBpZCBgZm9vYFxuICAgKiBjbGllbnQub24oXCJldmVudFwiLCBcImZvb1wiLCBcImRvd25saW5rL3NjaGVkdWxlZFwiLCBmdW5jdGlvbiAoZGV2SUQsIG1lc3NhZ2UpIHt9KVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBsaXN0ZW5zIHRvIHRoZSBgZG93bmxpbmsvc2NoZWR1bGVkYCBldmVudHMgZm9yIGFsbCBkZXZpY2VzXG4gICAqIGNsaWVudC5vbihcImV2ZW50XCIsIFwiK1wiLCBcImRvd25saW5rL3NjaGVkdWxlZFwiLCBmdW5jdGlvbiAoZGV2SUQsIG1lc3NhZ2UpIHt9KVxuICAgKi9cbiAgb24gKGV2ZW50IDogc3RyaW5nLCAuLi5hcmdzIDogQXJyYXk8Kj4pIDogdm9pZCB7XG4gICAgcmV0dXJuIHRoaXMudG9nZ2xlKHRydWUsIGV2ZW50LCAuLi5hcmdzKVxuICB9XG5cbiAgLyoqXG4gICAqIFN0b3AgbGlzdGVuaW5nIHRvIGV2ZW50cy5cbiAgICogVGhlIGFyZ3VtZW50IHN0cnVjdHVyZSBpcyB0aGUgc2FtZSBhcyBmb3IgYG9uKClgLlxuICAgKi9cbiAgb2ZmIChldmVudCA6IHN0cmluZywgLi4uYXJncyA6IEFycmF5PCo+KSA6IHZvaWQge1xuICAgIHJldHVybiB0aGlzLnRvZ2dsZShmYWxzZSwgZXZlbnQsIC4uLmFyZ3MpXG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogVG9nZ2xlcyB0aGUgc3Vic2NyaXB0aW9uIG1hdGNoaW5nIHRvIHRoZSByZWNlaXZlZCBhcmd1bWVudHNcbiAgICpcbiAgICovXG4gIHRvZ2dsZSAob24gOiBib29sZWFuLCBldmVudCA6IHN0cmluZywgLi4uYXJncyA6IEFycmF5PCo+KSA6IHZvaWQge1xuICAgIGlmIChhcmdzLmxlbmd0aCA8IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5lZWQgYXQgbGVhc3Qgb25lIGFyZ3VtZW50IHRvIG9uXCIpXG4gICAgfVxuXG4gICAgY29uc3QgWyAuLi5yZXN0IF0gPSBhcmdzXG4gICAgY29uc3QgY2IgPSByZXN0LnBvcCgpXG5cbiAgICBsZXQgdCA9IG51bGxcblxuICAgIHN3aXRjaCAoZXZlbnQpIHtcbiAgICBjYXNlIFwidXBsaW5rXCI6XG4gICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgIHQgPSB1cGxpbmtUb3BpYyguLi5yZXN0KVxuICAgICAgYnJlYWtcbiAgICBjYXNlIFwiZGV2aWNlXCI6XG4gICAgY2FzZSBcImV2ZW50XCI6XG4gICAgY2FzZSBcImV2ZW50c1wiOlxuICAgICAgdCA9IGV2ZW50VG9waWMoLi4ucmVzdClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSBcImFjdGl2YXRpb25cIjpcbiAgICBjYXNlIFwiYWN0aXZhdGlvbnNcIjpcbiAgICAgIGNvbnN0IFsgZGV2SUQgPSB3aWxkY2FyZCBdID0gcmVzdFxuICAgICAgdCA9IGV2ZW50VG9waWMoZGV2SUQsIFwiYWN0aXZhdGlvbnNcIilcbiAgICAgIGJyZWFrXG4gICAgY2FzZSBcImVycm9yXCI6XG4gICAgY2FzZSBcImNvbm5lY3RcIjpcbiAgICBjYXNlIFwicmVjb25uZWN0XCI6XG4gICAgY2FzZSBcImRpc2Nvbm5lY3RcIjpcbiAgICBjYXNlIFwiY2xvc2VcIjpcbiAgICAgIHRoaXMuZW1pdHRlci5vbihldmVudCwgY2IpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAodCA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGJ1aWxkIHRvcGljXCIpXG4gICAgfVxuXG4gICAgaWYgKG9uKSB7XG4gICAgICB0aGlzLnN1YnNjcmliZSh0LCBjYilcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy51bnN1YnNjcmliZSh0LCBjYilcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2VuZCBhIGRvd25saW5rIG1lc3NhZ2UgdG8gdGhlIGRldmljZSB3aXRoIHRoZSBzcGVjaWZpZWQgZGV2aWNlIElELlxuICAgKlxuICAgKiBAcGFyYW0gZGV2SUQgLSBUaGUgZGV2aWNlIElEIG9mIHRoZSBkZXZpY2UgdG8gc2VuZCB0aGUgZG93bmxpbmsgdG8uXG4gICAqIEBwYXJhbSBwYXlsb2FkIC0gVGhlIHJhdyBwYXlsb2FkIGFzIGEgQnVmZmVyLCBhbiBBcnJheSBvZiBudW1iZXJzLCBhIGhleCBzdHJpbmcgIG9yIGFuIG9iamVjdCBvZiBwYXlsb2FkIGZpZWxkcy5cbiAgICogQHBhcmFtIHBvcnQgLSBUaGUgcG9ydCB0byBzZW5kIHRoZSBtZXNzYWdlIG9uLlxuICAgKiBAcGFyYW0gY29uZmlybWVkIC0gU2V0IHRvIHRydWUgZm9yIGNvbmZpcm1lZCBkb3dubGluay5cbiAgICogQHBhcmFtIHNjaGVkdWxlIC0gU2V0IHRvIHRoZSBzY2hlZHVsaW5nIHlvdSB3YW50IHRvIHVzZSAoZmlyc3QsIGxhc3Qgb3IgcmVwbGFjZSkuXG4gICAqL1xuICBzZW5kIChkZXZJRCA6IERldmljZUlELCBwYXlsb2FkIDogUGF5bG9hZEFycmF5IHwgUGF5bG9hZFJhdyB8IFN0cmluZyB8IFBheWxvYWRGaWVsZHMsIHBvcnQgOiBudW1iZXIgPSAxLCBjb25maXJtZWQgOiBib29sZWFuID0gZmFsc2UsIHNjaGVkdWxlIDogU2NoZWR1bGUgPSBcInJlcGxhY2VcIikge1xuICAgIGNvbnN0IHQgPSBkb3dubGlua1RvcGljKHRoaXMuYXBwSUQsIGRldklEKVxuICAgIGNvbnN0IG1lc3NhZ2UgOiBEb3dubGlua01lc3NhZ2UgPSB7XG4gICAgICBwb3J0LFxuICAgICAgY29uZmlybWVkLFxuICAgICAgc2NoZWR1bGUsXG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkocGF5bG9hZCkpIHtcbiAgICAgIG1lc3NhZ2UucGF5bG9hZF9yYXcgPSBuZXcgQnVmZmVyKHBheWxvYWQpLnRvU3RyaW5nKFwiYmFzZTY0XCIpXG4gICAgfSBlbHNlIGlmIChwYXlsb2FkIGluc3RhbmNlb2YgQnVmZmVyKSB7XG4gICAgICBtZXNzYWdlLnBheWxvYWRfcmF3ID0gcGF5bG9hZC50b1N0cmluZyhcImJhc2U2NFwiKVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHBheWxvYWQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIG1lc3NhZ2UucGF5bG9hZF9yYXcgPSBuZXcgQnVmZmVyKHBheWxvYWQsIFwiaGV4XCIpLnRvU3RyaW5nKFwiYmFzZTY0XCIpXG4gICAgfSBlbHNlIHtcbiAgICAgIG1lc3NhZ2UucGF5bG9hZF9maWVsZHMgPSBwYXlsb2FkXG4gICAgfVxuXG4gICAgZGVidWcoXCJwdWJsaXNoaW5nIG1lc3NhZ2UgdG8gJXM6ICVPXCIsIHQsIG1lc3NhZ2UpXG5cbiAgICB0aGlzLm1xdHQucHVibGlzaCh0LCBKU09OLnN0cmluZ2lmeShtZXNzYWdlKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBgb25FcnJvcmAgaXMgY2FsbGVkIHdoZW5ldmVyIHRoZXJlJ3MgYW4gZXJyb3IgaW4gdGhlIE1RVFQgY2xpZW50LlxuICAgKi9cbiAgb25FcnJvciAoZXJyIDogYW55KSA6IHZvaWQge1xuICAgIGRlYnVnKFwibXF0dCBjbGllbnQgcmVjZWl2ZWQgZXJyb3I6ICVzXCIsIGVycilcbiAgICB0aGlzLmVtaXR0ZXIuZW1pdChcImVycm9yXCIsIGVycilcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBgb25Db25uZWN0YCBpcyBjYWxsZWQgd2hlbmV2ZXIgdGhlIE1RVFQgY2xpZW50IChyZS0pY29ubmVjdHMuXG4gICAqL1xuICBvbkNvbm5lY3QgKGFjayA6IENvbm5hY2spIDogdm9pZCB7XG4gICAgZGVidWcoXCJtcXR0IGNsaWVudCBjb25uZWN0ZWRcIilcbiAgICB0aGlzLmVtaXR0ZXIuZW1pdChcImNvbm5lY3RcIiwgYWNrKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIGBvblJlY29ubmVjdGAgaXMgY2FsbGVkIHdoZW5ldmVyIHRoZSBNUVRUIGNsaWVudCBzdGFydHMgcmVjb25uZWN0aW5nLlxuICAgKi9cbiAgb25SZWNvbm5lY3QgKCkgOiB2b2lkIHtcbiAgICBkZWJ1ZyhcIm1xdHQgY2xpZW50IHJlY29ubmVjdGluZ1wiKVxuICAgIHRoaXMuZW1pdHRlci5lbWl0KFwicmVjb25uZWN0XCIsIHVuZGVmaW5lZClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBgb25EaXNjb25uZWN0YCBpcyBjYWxsZWQgd2hlbmV2ZXIgdGhlIE1RVFQgY2xpZW50IGxvc3QgaXRzIGNvbm5lY3Rpb24sXG4gICAqIGFmdGVyIHRoZSBrZWVwYWxpdmUgaGFzIHRpbWVkIG91dC5cbiAgICovXG4gIG9uRGlzY29ubmVjdCAoKSA6IHZvaWQge1xuICAgIGRlYnVnKFwibXF0dCBjbGllbnQgZGlzY29ubmVjdGVkXCIpXG4gICAgdGhpcy5lbWl0dGVyLmVtaXQoXCJkaXNjb25uZWN0XCIsIHVuZGVmaW5lZClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBgb25DbG9zZWAgaXMgY2FsbGVkIGFmdGVyIHRoZSBNUVRUIGRpc2Nvbm5lY3RzLlxuICAgKi9cbiAgb25DbG9zZSAoKSA6IHZvaWQge1xuICAgIGRlYnVnKFwibXF0dCBjbGllbnQgZGlzY29ubmVjdGVkXCIpXG4gICAgdGhpcy5lbWl0dGVyLmVtaXQoXCJjbG9zZVwiLCB1bmRlZmluZWQpXG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogYG9uTWVzc2FnZWAgaXMgY2FsbGVkIHdoZW4gYSBuZXcgbWVzc2FnZSBpcyByZWNlaXZlZCBmcm9tIGFueSBzdWJzY3JpcHRpb24uXG4gICAqL1xuICBvbk1lc3NhZ2UgKHRvcGljIDogc3RyaW5nLCBtZXNzYWdlIDogYW55KSA6IHZvaWQge1xuICAgIGNvbnN0IHBheWxvYWQgPSBKU09OLnBhcnNlKG1lc3NhZ2UudG9TdHJpbmcoKSlcblxuICAgIGlmIChwYXlsb2FkICYmIHR5cGVvZiBwYXlsb2FkLnBheWxvYWRfcmF3ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBwYXlsb2FkLnBheWxvYWRfcmF3ID0gbmV3IEJ1ZmZlcihwYXlsb2FkLnBheWxvYWRfcmF3LCBcImJhc2U2NFwiKVxuICAgIH1cblxuICAgIGRlYnVnKFwicmVjZWl2ZWQgbWVzc2FnZSBvbiB0b3BpYyBgJXNgOiAlT1wiLCB0b3BpYywgcGF5bG9hZClcblxuICAgIGNvbnN0IGRldiA9IGRldklEKHRvcGljKVxuICAgIHZhbGlkV2lsZGNhcmRzKHRvcGljKS5mb3JFYWNoKHRvcGljID0+IHRoaXMuZW1pdHRlci5lbWl0KHRvcGljLCBkZXYsIHBheWxvYWQpKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIGBzdWJzY3JpYmVgIHN1YnNjcmliZXMgdGhlIG1xdHQgY2xpZW50IHRvIHRoZSBzcGVjaWZpZWQgdG9waWMgYW5kIGhvb2tzIHVwXG4gICAqIHRoZSBjYWxsYmFjayBpbiB0aGUgZXZlbnQgZW1pdHRlci5cbiAgICovXG4gIHN1YnNjcmliZSAodG9waWMgOiBzdHJpbmcsIGNiIDogRnVuY3Rpb24pIDogdm9pZCB7XG4gICAgZGVidWcoXCJzdWJzY3JpYmluZyB0byBtZXNzYWdlcyBvbiB0b3BpYyBgJXNgXCIsIHRvcGljKVxuICAgIHRoaXMubXF0dC5zdWJzY3JpYmUodG9waWMpXG4gICAgdGhpcy5lbWl0dGVyLm9uKHRvcGljLCBjYilcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBgdW5zdWJzY3JpYmVgIHVuc3Vic2NyaWJlcyB0aGUgbXF0dCBjbGllbnQgZnJvbSB0aGUgc3BlY2lmaWVkIHRvcGljIGFuZFxuICAgKiByZW1vdmVzIHRoZSBjYWxsYmFjayBmcm9tIHRoZSBldmVudCBlbWl0dGVyLlxuICAgKi9cbiAgdW5zdWJzY3JpYmUgKHRvcGljIDogc3RyaW5nLCBjYiA6IEZ1bmN0aW9uKSA6IHZvaWQge1xuICAgIGRlYnVnKFwidW5zdWJzY3JpYmluZyBmcm9tIG1lc3NhZ2VzIG9uIHRvcGljIGAlc2BcIiwgdG9waWMpXG4gICAgdGhpcy5tcXR0LnVuc3Vic2NyaWJlKHRvcGljKVxuICAgIHRoaXMuZW1pdHRlci5yZW1vdmVMaXN0ZW5lcih0b3BpYywgY2IpXG4gIH1cbn1cbiJdfQ==